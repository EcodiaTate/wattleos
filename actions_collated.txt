

===== D:\.code\wattleos\src\lib\actions\admissions\email-templates.ts =====

// src/lib/actions/admissions/email-templates.ts
//
// ============================================================
// WattleOS V2 — Module 13: Email Template Server Actions
// ============================================================
// Manages reusable email templates for admissions pipeline
// communication. Templates support merge tags that are
// resolved at send time from waitlist entry data.
//
// Templates can be set to auto-trigger when an entry moves
// to a specific stage (e.g., send "Tour Invitation" when
// entry moves to 'tour_scheduled'). The actual email sending
// is handled by an Edge Function or integration pipe —
// these actions manage the templates and render content.
//
// WHY templates not freeform: Schools send the same emails
// hundreds of times. Templates ensure consistent branding,
// reduce admin effort, and make the pipeline automated.
// ============================================================

"use server";

import { requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type { WaitlistEntry, WaitlistStage } from "./waitlist-pipeline";

// ============================================================
// Types
// ============================================================

export interface EmailTemplate {
  id: string;
  tenant_id: string;
  name: string;
  trigger_stage: WaitlistStage | null;
  subject: string;
  body: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface RenderedEmail {
  subject: string;
  body: string;
}

/**
 * Supported merge tags for email templates.
 * These are resolved from the waitlist entry at send time.
 */
export const MERGE_TAGS = {
  "{{child_first_name}}": "Child first name",
  "{{child_last_name}}": "Child full last name",
  "{{child_full_name}}": "Child first + last name",
  "{{child_dob}}": "Child date of birth",
  "{{parent_first_name}}": "Parent first name",
  "{{parent_last_name}}": "Parent last name",
  "{{parent_full_name}}": "Parent first + last name",
  "{{parent_email}}": "Parent email",
  "{{requested_program}}": "Requested program",
  "{{requested_start}}": "Requested start term",
  "{{offered_program}}": "Offered program",
  "{{offered_start_date}}": "Offered start date",
  "{{offer_expires_at}}": "Offer expiry date",
  "{{tour_date}}": "Scheduled tour date",
  "{{school_name}}": "School name",
  "{{inquiry_date}}": "Date of initial inquiry",
  "{{stage}}": "Current pipeline stage",
} as const;

// ============================================================
// Input Types
// ============================================================

export interface CreateEmailTemplateInput {
  name: string;
  trigger_stage?: WaitlistStage | null;
  subject: string;
  body: string;
}

export interface UpdateEmailTemplateInput {
  name?: string;
  trigger_stage?: WaitlistStage | null;
  subject?: string;
  body?: string;
  is_active?: boolean;
}

// ============================================================
// CREATE TEMPLATE
// ============================================================
// Permission: MANAGE_EMAIL_TEMPLATES
// ============================================================

export async function createEmailTemplate(
  input: CreateEmailTemplateInput,
): Promise<ActionResponse<EmailTemplate>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_EMAIL_TEMPLATES);
    const supabase = await createSupabaseServerClient();

    if (!input.name?.trim()) {
      return failure("Template name is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.subject?.trim()) {
      return failure("Subject is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.body?.trim()) {
      return failure("Body is required", ErrorCodes.VALIDATION_ERROR);
    }

    // If trigger_stage is set, ensure no other active template
    // already triggers on the same stage (one per stage max)
    if (input.trigger_stage) {
      const { data: existing } = await supabase
        .from("email_templates")
        .select("id, name")
        .eq("trigger_stage", input.trigger_stage)
        .eq("is_active", true)
        .is("deleted_at", null)
        .limit(1);

      if (existing && existing.length > 0) {
        const other = existing[0] as { id: string; name: string };
        return failure(
          `Template "${other.name}" already triggers on stage '${input.trigger_stage}'. Deactivate it first or remove the trigger.`,
          ErrorCodes.ALREADY_EXISTS,
        );
      }
    }

    const { data, error } = await supabase
      .from("email_templates")
      .insert({
        tenant_id: context.tenant.id,
        name: input.name.trim(),
        trigger_stage: input.trigger_stage ?? null,
        subject: input.subject.trim(),
        body: input.body.trim(),
        is_active: true,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as EmailTemplate);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create template";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE TEMPLATE
// ============================================================

export async function updateEmailTemplate(
  templateId: string,
  input: UpdateEmailTemplateInput,
): Promise<ActionResponse<EmailTemplate>> {
  try {
    await requirePermission(Permissions.MANAGE_EMAIL_TEMPLATES);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.name !== undefined) updateData.name = input.name.trim();
    if (input.trigger_stage !== undefined)
      updateData.trigger_stage = input.trigger_stage;
    if (input.subject !== undefined) updateData.subject = input.subject.trim();
    if (input.body !== undefined) updateData.body = input.body.trim();
    if (input.is_active !== undefined) updateData.is_active = input.is_active;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    // If activating a trigger_stage, check for conflicts
    if (input.trigger_stage && input.is_active !== false) {
      const { data: existing } = await supabase
        .from("email_templates")
        .select("id")
        .eq("trigger_stage", input.trigger_stage)
        .eq("is_active", true)
        .neq("id", templateId)
        .is("deleted_at", null)
        .limit(1);

      if (existing && existing.length > 0) {
        return failure(
          `Another active template already triggers on stage '${input.trigger_stage}'`,
          ErrorCodes.ALREADY_EXISTS,
        );
      }
    }

    const { data, error } = await supabase
      .from("email_templates")
      .update(updateData)
      .eq("id", templateId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EmailTemplate);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update template";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE TEMPLATE (soft delete)
// ============================================================

export async function deleteEmailTemplate(
  templateId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(Permissions.MANAGE_EMAIL_TEMPLATES);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("email_templates")
      .update({ deleted_at: new Date().toISOString(), is_active: false })
      .eq("id", templateId)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete template";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST TEMPLATES
// ============================================================
// Permission: MANAGE_EMAIL_TEMPLATES
// Returns all templates sorted by name. No pagination needed
// — schools typically have 5–15 templates max.
// ============================================================

export async function listEmailTemplates(): Promise<
  ActionResponse<EmailTemplate[]>
> {
  try {
    await requirePermission(Permissions.MANAGE_EMAIL_TEMPLATES);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("email_templates")
      .select("*")
      .is("deleted_at", null)
      .order("name", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as EmailTemplate[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list templates";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SINGLE TEMPLATE
// ============================================================

export async function getEmailTemplate(
  templateId: string,
): Promise<ActionResponse<EmailTemplate>> {
  try {
    await requirePermission(Permissions.MANAGE_EMAIL_TEMPLATES);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("email_templates")
      .select("*")
      .eq("id", templateId)
      .is("deleted_at", null)
      .single();

    if (error) {
      return failure("Template not found", ErrorCodes.NOT_FOUND);
    }

    return success(data as EmailTemplate);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get template";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// RENDER TEMPLATE (resolve merge tags)
// ============================================================
// Takes a template and a waitlist entry, returns the rendered
// subject and body with all merge tags replaced. This is a
// pure function used before sending.
//
// WHY server-side rendering: Merge tags contain PII (names,
// emails). Rendering on the server ensures no raw template
// with PII leaks to the client before it's intentionally sent.
// ============================================================

export async function renderTemplate(
  templateId: string,
  entryId: string,
): Promise<ActionResponse<RenderedEmail>> {
  try {
    await requirePermission(Permissions.MANAGE_EMAIL_TEMPLATES);
    const supabase = await createSupabaseServerClient();

    // Get template
    const { data: template, error: tplError } = await supabase
      .from("email_templates")
      .select("*")
      .eq("id", templateId)
      .is("deleted_at", null)
      .single();

    if (tplError || !template) {
      return failure("Template not found", ErrorCodes.NOT_FOUND);
    }

    // Get waitlist entry
    const { data: entry, error: entryError } = await supabase
      .from("waitlist_entries")
      .select("*")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (entryError || !entry) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const tpl = template as EmailTemplate;
    const wl = entry as WaitlistEntry;

    // Get school name from tenant
    const { data: tenant } = await supabase
      .from("tenants")
      .select("name")
      .eq("id", wl.tenant_id)
      .single();

    const schoolName = tenant
      ? (tenant as { name: string }).name
      : "Our School";

    // Build merge tag values
    const tagValues: Record<string, string> = {
      "{{child_first_name}}": wl.child_first_name,
      "{{child_last_name}}": wl.child_last_name,
      "{{child_full_name}}": `${wl.child_first_name} ${wl.child_last_name}`,
      "{{child_dob}}": wl.child_date_of_birth,
      "{{parent_first_name}}": wl.parent_first_name,
      "{{parent_last_name}}": wl.parent_last_name,
      "{{parent_full_name}}": `${wl.parent_first_name} ${wl.parent_last_name}`,
      "{{parent_email}}": wl.parent_email,
      "{{requested_program}}": wl.requested_program ?? "",
      "{{requested_start}}": wl.requested_start ?? "",
      "{{offered_program}}": wl.offered_program ?? "",
      "{{offered_start_date}}": wl.offered_start_date ?? "",
      "{{offer_expires_at}}": wl.offer_expires_at
        ? new Date(wl.offer_expires_at).toLocaleDateString("en-AU")
        : "",
      "{{tour_date}}": wl.tour_date
        ? new Date(wl.tour_date).toLocaleDateString("en-AU", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
          })
        : "",
      "{{school_name}}": schoolName,
      "{{inquiry_date}}": wl.inquiry_date,
      "{{stage}}": wl.stage,
    };

    // Replace all tags
    let renderedSubject = tpl.subject;
    let renderedBody = tpl.body;

    for (const [tag, value] of Object.entries(tagValues)) {
      renderedSubject = renderedSubject.replaceAll(tag, value);
      renderedBody = renderedBody.replaceAll(tag, value);
    }

    return success({
      subject: renderedSubject,
      body: renderedBody,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to render template";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET TRIGGERED TEMPLATE FOR STAGE
// ============================================================
// Internal helper: finds the active template configured to
// auto-trigger when an entry moves to a specific stage.
// Returns null if no template is configured.
//
// Called by transitionStage() in waitlist-pipeline.ts to
// determine if an email should be queued when stage changes.
// ============================================================

export async function getTriggeredTemplate(
  stage: WaitlistStage,
): Promise<ActionResponse<EmailTemplate | null>> {
  try {
    await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("email_templates")
      .select("*")
      .eq("trigger_stage", stage)
      .eq("is_active", true)
      .is("deleted_at", null)
      .limit(1)
      .maybeSingle();

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data as EmailTemplate) ?? null);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get triggered template";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET AVAILABLE MERGE TAGS
// ============================================================
// Returns the list of supported merge tags with descriptions.
// Used by the template editor UI to show an insertion palette.
// ============================================================

export async function getAvailableMergeTags(): Promise<
  ActionResponse<Array<{ tag: string; description: string }>>
> {
  const tags = Object.entries(MERGE_TAGS).map(([tag, description]) => ({
    tag,
    description,
  }));

  return success(tags);
}

// ============================================================
// PREVIEW TEMPLATE (with sample data)
// ============================================================
// Renders a template with realistic sample data so admins
// can see what the email will look like before saving.
// No database lookup needed — uses hardcoded sample values.
// ============================================================

export async function previewTemplate(
  subject: string,
  body: string,
): Promise<ActionResponse<RenderedEmail>> {
  const sampleValues: Record<string, string> = {
    "{{child_first_name}}": "Sophia",
    "{{child_last_name}}": "Chen",
    "{{child_full_name}}": "Sophia Chen",
    "{{child_dob}}": "2020-03-15",
    "{{parent_first_name}}": "Michelle",
    "{{parent_last_name}}": "Chen",
    "{{parent_full_name}}": "Michelle Chen",
    "{{parent_email}}": "michelle@example.com",
    "{{requested_program}}": "Primary 3-6",
    "{{requested_start}}": "Term 1 2027",
    "{{offered_program}}": "Primary 3-6",
    "{{offered_start_date}}": "2027-01-28",
    "{{offer_expires_at}}": "15 December 2026",
    "{{tour_date}}": "Wednesday, 20 November 2026, 10:00 AM",
    "{{school_name}}": "Riverside Montessori",
    "{{inquiry_date}}": "2026-06-15",
    "{{stage}}": "waitlisted",
  };

  let renderedSubject = subject;
  let renderedBody = body;

  for (const [tag, value] of Object.entries(sampleValues)) {
    renderedSubject = renderedSubject.replaceAll(tag, value);
    renderedBody = renderedBody.replaceAll(tag, value);
  }

  return success({
    subject: renderedSubject,
    body: renderedBody,
  });
}


===== D:\.code\wattleos\src\lib\actions\admissions\tour-slots.ts =====

// src/lib/actions/admissions/tour-slots.ts
//
// ============================================================
// WattleOS V2 — Module 13: Tour Slot Server Actions
// ============================================================
// Tour slots are time windows where prospective families can
// visit the school. Admins create slots with capacity; public
// pages show available slots for self-service booking.
//
// Tours connect to the waitlist pipeline: when a family books
// a tour, their waitlist entry moves to 'tour_scheduled'.
// After attending, staff marks it 'tour_completed'.
//
// WHY separate from the waitlist entry: A tour slot is shared
// capacity (5 families per slot). The waitlist entry is per-
// child. Multiple waitlist entries can book the same tour slot.
// ============================================================

"use server";

import { requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  ActionResponse,
  ErrorCodes,
  failure,
  paginated,
  paginatedFailure,
  PaginatedResponse,
  success,
} from "@/types/api";
import type { User } from "@/types/domain";
import type { WaitlistEntry, WaitlistStage } from "./waitlist-pipeline";

// ============================================================
// Types
// ============================================================

export interface TourSlot {
  id: string;
  tenant_id: string;
  date: string;
  start_time: string;
  end_time: string;
  max_families: number;
  guide_id: string | null;
  location: string | null;
  notes: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface TourSlotWithDetails extends TourSlot {
  guide: Pick<User, "id" | "first_name" | "last_name"> | null;
  booked_count: number;
  attended_count: number;
  bookings: TourBooking[];
}

export interface TourBooking {
  entry_id: string;
  child_name: string;
  parent_name: string;
  parent_email: string;
  tour_attended: boolean | null;
}

/** Public-facing slot for the tours page */
export interface AvailableTourSlot {
  id: string;
  date: string;
  start_time: string;
  end_time: string;
  location: string | null;
  spots_remaining: number;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateTourSlotInput {
  date: string;
  start_time: string;
  end_time: string;
  max_families?: number;
  guide_id?: string | null;
  location?: string | null;
  notes?: string | null;
}

export interface UpdateTourSlotInput {
  date?: string;
  start_time?: string;
  end_time?: string;
  max_families?: number;
  guide_id?: string | null;
  location?: string | null;
  notes?: string | null;
  is_active?: boolean;
}

export interface ListTourSlotsParams {
  from_date?: string;
  to_date?: string;
  guide_id?: string;
  is_active?: boolean;
  page?: number;
  per_page?: number;
}

// ============================================================
// CREATE TOUR SLOT
// ============================================================
// Permission: MANAGE_TOURS
// ============================================================

export async function createTourSlot(
  input: CreateTourSlotInput,
): Promise<ActionResponse<TourSlot>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    if (!input.date) {
      return failure("Tour date is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.start_time || !input.end_time) {
      return failure(
        "Start and end times are required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("tour_slots")
      .insert({
        tenant_id: context.tenant.id,
        date: input.date,
        start_time: input.start_time,
        end_time: input.end_time,
        max_families: input.max_families ?? 5,
        guide_id: input.guide_id ?? null,
        location: input.location?.trim() ?? null,
        notes: input.notes?.trim() ?? null,
        is_active: true,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as TourSlot);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create tour slot";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// BULK CREATE TOUR SLOTS
// ============================================================
// Permission: MANAGE_TOURS
// Creates multiple slots at once (e.g., every Wednesday at
// 10am for the next term).
// ============================================================

export interface BulkCreateTourSlotsInput {
  dates: string[];
  start_time: string;
  end_time: string;
  max_families?: number;
  guide_id?: string | null;
  location?: string | null;
}

export async function bulkCreateTourSlots(
  input: BulkCreateTourSlotsInput,
): Promise<ActionResponse<{ created: number }>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    if (input.dates.length === 0) {
      return failure(
        "At least one date is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const slots = input.dates.map((date) => ({
      tenant_id: context.tenant.id,
      date,
      start_time: input.start_time,
      end_time: input.end_time,
      max_families: input.max_families ?? 5,
      guide_id: input.guide_id ?? null,
      location: input.location?.trim() ?? null,
      is_active: true,
    }));

    const { data, error } = await supabase
      .from("tour_slots")
      .insert(slots)
      .select("id");

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success({ created: data?.length ?? 0 });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create tour slots";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE TOUR SLOT
// ============================================================

export async function updateTourSlot(
  slotId: string,
  input: UpdateTourSlotInput,
): Promise<ActionResponse<TourSlot>> {
  try {
    await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.date !== undefined) updateData.date = input.date;
    if (input.start_time !== undefined)
      updateData.start_time = input.start_time;
    if (input.end_time !== undefined) updateData.end_time = input.end_time;
    if (input.max_families !== undefined)
      updateData.max_families = input.max_families;
    if (input.guide_id !== undefined) updateData.guide_id = input.guide_id;
    if (input.location !== undefined)
      updateData.location = input.location?.trim() ?? null;
    if (input.notes !== undefined)
      updateData.notes = input.notes?.trim() ?? null;
    if (input.is_active !== undefined) updateData.is_active = input.is_active;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("tour_slots")
      .update(updateData)
      .eq("id", slotId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as TourSlot);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update tour slot";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE TOUR SLOT (soft delete)
// ============================================================

export async function deleteTourSlot(
  slotId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("tour_slots")
      .update({ deleted_at: new Date().toISOString(), is_active: false })
      .eq("id", slotId)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete tour slot";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST TOUR SLOTS (Staff view — with bookings)
// ============================================================
// Permission: MANAGE_TOURS
// ============================================================

export async function listTourSlots(
  params: ListTourSlotsParams = {},
): Promise<PaginatedResponse<TourSlotWithDetails>> {
  try {
    await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 25;
    const offset = (page - 1) * perPage;

    // Count
    let countQuery = supabase
      .from("tour_slots")
      .select("id", { count: "exact", head: true })
      .is("deleted_at", null);

    if (params.from_date) countQuery = countQuery.gte("date", params.from_date);
    if (params.to_date) countQuery = countQuery.lte("date", params.to_date);
    if (params.guide_id)
      countQuery = countQuery.eq("guide_id", params.guide_id);
    if (params.is_active !== undefined)
      countQuery = countQuery.eq("is_active", params.is_active);

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    let query = supabase
      .from("tour_slots")
      .select(
        `
        *,
        guide:users!tour_slots_guide_id_fkey(id, first_name, last_name)
      `,
      )
      .is("deleted_at", null)
      .order("date", { ascending: true })
      .order("start_time", { ascending: true })
      .range(offset, offset + perPage - 1);

    if (params.from_date) query = query.gte("date", params.from_date);
    if (params.to_date) query = query.lte("date", params.to_date);
    if (params.guide_id) query = query.eq("guide_id", params.guide_id);
    if (params.is_active !== undefined)
      query = query.eq("is_active", params.is_active);

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Enrich with booking data from waitlist_entries
    const slots: TourSlotWithDetails[] = [];

    for (const row of (data ?? []) as Array<Record<string, unknown>>) {
      const slotId = row.id as string;

      // Get waitlist entries booked for this tour slot
      // Tour bookings are linked via tour_date matching the slot's date+time
      const slotDatetime = `${row.date}T${row.start_time}`;

      const { data: bookedEntries } = await supabase
        .from("waitlist_entries")
        .select(
          "id, child_first_name, child_last_name, parent_first_name, parent_last_name, parent_email, tour_attended",
        )
        .eq("tour_date", slotDatetime)
        .in("stage", [
          "tour_scheduled",
          "tour_completed",
          "offered",
          "accepted",
          "enrolled",
        ])
        .is("deleted_at", null);

      const bookings: TourBooking[] = (
        (bookedEntries ?? []) as Array<{
          id: string;
          child_first_name: string;
          child_last_name: string;
          parent_first_name: string;
          parent_last_name: string;
          parent_email: string;
          tour_attended: boolean | null;
        }>
      ).map((e) => ({
        entry_id: e.id,
        child_name: `${e.child_first_name} ${e.child_last_name}`,
        parent_name: `${e.parent_first_name} ${e.parent_last_name}`,
        parent_email: e.parent_email,
        tour_attended: e.tour_attended,
      }));

      slots.push({
        id: row.id as string,
        tenant_id: row.tenant_id as string,
        date: row.date as string,
        start_time: row.start_time as string,
        end_time: row.end_time as string,
        max_families: row.max_families as number,
        guide_id: row.guide_id as string | null,
        location: row.location as string | null,
        notes: row.notes as string | null,
        is_active: row.is_active as boolean,
        created_at: row.created_at as string,
        updated_at: row.updated_at as string,
        deleted_at: row.deleted_at as string | null,
        guide: row.guide as Pick<
          User,
          "id" | "first_name" | "last_name"
        > | null,
        booked_count: bookings.length,
        attended_count: bookings.filter((b) => b.tour_attended === true).length,
        bookings,
      });
    }

    return paginated(slots, total, page, perPage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list tour slots";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET AVAILABLE TOUR SLOTS (Public — no auth)
// ============================================================
// Returns future active slots with remaining capacity.
// Used on the public {school}.wattleos.au/tours page.
// ============================================================

export async function getAvailableTourSlots(
  tenantId: string,
): Promise<ActionResponse<AvailableTourSlot[]>> {
  try {
    const supabase = await createSupabaseServerClient();

    const today = new Date().toISOString().split("T")[0];

    const { data: slots, error } = await supabase
      .from("tour_slots")
      .select("id, date, start_time, end_time, max_families, location")
      .eq("tenant_id", tenantId)
      .eq("is_active", true)
      .gte("date", today)
      .is("deleted_at", null)
      .order("date", { ascending: true })
      .order("start_time", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    const availableSlots: AvailableTourSlot[] = [];

    for (const slot of (slots ?? []) as Array<{
      id: string;
      date: string;
      start_time: string;
      end_time: string;
      max_families: number;
      location: string | null;
    }>) {
      // Count current bookings for this slot
      const slotDatetime = `${slot.date}T${slot.start_time}`;

      const { count: bookedCount } = await supabase
        .from("waitlist_entries")
        .select("id", { count: "exact", head: true })
        .eq("tenant_id", tenantId)
        .eq("tour_date", slotDatetime)
        .in("stage", [
          "tour_scheduled",
          "tour_completed",
          "offered",
          "accepted",
          "enrolled",
        ])
        .is("deleted_at", null);

      const spotsRemaining = slot.max_families - (bookedCount ?? 0);

      if (spotsRemaining > 0) {
        availableSlots.push({
          id: slot.id,
          date: slot.date,
          start_time: slot.start_time,
          end_time: slot.end_time,
          location: slot.location,
          spots_remaining: spotsRemaining,
        });
      }
    }

    return success(availableSlots);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get available tours";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// BOOK TOUR (Links waitlist entry to a tour slot)
// ============================================================
// Permission: MANAGE_TOURS (admin books on behalf) or
// MANAGE_WAITLIST. Also called from public tour booking
// flow after selecting a slot.
//
// WHY link via tour_date: Tour slots are date+time windows.
// The waitlist entry stores the tour_date as a TIMESTAMPTZ
// matching the slot's date+start_time. This lets us count
// bookings per slot without a junction table.
// ============================================================

export async function bookTour(
  entryId: string,
  tourSlotId: string,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    // Get the tour slot
    const { data: slot, error: slotError } = await supabase
      .from("tour_slots")
      .select("id, date, start_time, max_families, tenant_id")
      .eq("id", tourSlotId)
      .eq("is_active", true)
      .is("deleted_at", null)
      .single();

    if (slotError || !slot) {
      return failure("Tour slot not found or inactive", ErrorCodes.NOT_FOUND);
    }

    const tourSlot = slot as {
      id: string;
      date: string;
      start_time: string;
      max_families: number;
      tenant_id: string;
    };
    const tourDatetime = `${tourSlot.date}T${tourSlot.start_time}`;

    // Check capacity
    const { count: bookedCount } = await supabase
      .from("waitlist_entries")
      .select("id", { count: "exact", head: true })
      .eq("tenant_id", tourSlot.tenant_id)
      .eq("tour_date", tourDatetime)
      .in("stage", [
        "tour_scheduled",
        "tour_completed",
        "offered",
        "accepted",
        "enrolled",
      ])
      .is("deleted_at", null);

    if ((bookedCount ?? 0) >= tourSlot.max_families) {
      return failure(
        "This tour slot is fully booked",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Get current entry
    const { data: currentEntry } = await supabase
      .from("waitlist_entries")
      .select("stage, tenant_id")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (!currentEntry) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = currentEntry as { stage: WaitlistStage; tenant_id: string };
    const previousStage = entry.stage;

    // Update the entry with tour info + move to tour_scheduled
    const { data, error } = await supabase
      .from("waitlist_entries")
      .update({
        stage: "tour_scheduled" as WaitlistStage,
        tour_date: tourDatetime,
        tour_guide: null,
      })
      .eq("id", entryId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    // Log stage transition
    if (previousStage !== "tour_scheduled") {
      await supabase.from("waitlist_stage_history").insert({
        tenant_id: entry.tenant_id,
        waitlist_entry_id: entryId,
        from_stage: previousStage,
        to_stage: "tour_scheduled",
        changed_by: context.user.id,
        notes: `Tour booked for ${tourSlot.date} at ${tourSlot.start_time}`,
      });
    }

    return success(data as WaitlistEntry);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to book tour";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// RECORD TOUR ATTENDANCE
// ============================================================
// Permission: MANAGE_TOURS
// Marks whether the family attended the tour and adds notes.
// Moves entry to 'tour_completed' if attended.
// ============================================================

export async function recordTourAttendance(
  entryId: string,
  attended: boolean,
  tourNotes?: string,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_TOURS);
    const supabase = await createSupabaseServerClient();

    const { data: current } = await supabase
      .from("waitlist_entries")
      .select("stage, tenant_id")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (!current) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = current as { stage: WaitlistStage; tenant_id: string };

    if (entry.stage !== "tour_scheduled") {
      return failure(
        `Entry must be at 'tour_scheduled' to record attendance, currently '${entry.stage}'`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const newStage: WaitlistStage = attended ? "tour_completed" : "waitlisted";

    const { data, error } = await supabase
      .from("waitlist_entries")
      .update({
        stage: newStage,
        tour_attended: attended,
        tour_notes: tourNotes?.trim() ?? null,
      })
      .eq("id", entryId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    await supabase.from("waitlist_stage_history").insert({
      tenant_id: entry.tenant_id,
      waitlist_entry_id: entryId,
      from_stage: "tour_scheduled",
      to_stage: newStage,
      changed_by: context.user.id,
      notes: attended
        ? `Tour attended. ${tourNotes?.trim() ?? ""}`
        : `Tour not attended — moved back to waitlist. ${tourNotes?.trim() ?? ""}`,
    });

    return success(data as WaitlistEntry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to record attendance";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\admissions\waitlist-pipeline.ts =====

// src/lib/actions/admissions/waitlist-pipeline.ts
//
// ============================================================
// WattleOS V2 — Module 13: Waitlist & Admissions Pipeline
// ============================================================
// Manages the complete admissions journey from first inquiry
// to enrolled student. The pipeline stages are:
//
//   inquiry → waitlisted → tour_scheduled → tour_completed
//   → offered → accepted → enrolled
//   (with declined/withdrawn as terminal states)
//
// Every stage transition is logged in waitlist_stage_history
// for audit and analytics. The "accepted → enrolled" step
// bridges to Module 10 by converting the waitlist entry into
// a pre-filled enrollment application.
//
// WHY a pipeline not a flat list: Montessori schools often
// have multi-year waitlists. Visibility into where each
// family sits — and how long they've been there — is what
// lets admins manage capacity and parent expectations.
// ============================================================

"use server";

import { requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  ActionResponse,
  ErrorCodes,
  failure,
  paginated,
  paginatedFailure,
  PaginatedResponse,
  success,
} from "@/types/api";

// ============================================================
// Types
// ============================================================

export type WaitlistStage =
  | "inquiry"
  | "waitlisted"
  | "tour_scheduled"
  | "tour_completed"
  | "offered"
  | "accepted"
  | "enrolled"
  | "declined"
  | "withdrawn";

export type OfferResponse = "accepted" | "declined";

export interface WaitlistEntry {
  id: string;
  tenant_id: string;
  stage: WaitlistStage;
  priority: number;
  child_first_name: string;
  child_last_name: string;
  child_date_of_birth: string;
  child_gender: string | null;
  child_current_school: string | null;
  requested_program: string | null;
  requested_start: string | null;
  requested_start_date: string | null;
  parent_first_name: string;
  parent_last_name: string;
  parent_email: string;
  parent_phone: string | null;
  parent_user_id: string | null;
  siblings_at_school: boolean;
  sibling_names: string | null;
  how_heard_about_us: string | null;
  notes: string | null;
  admin_notes: string | null;
  tour_date: string | null;
  tour_guide: string | null;
  tour_notes: string | null;
  tour_attended: boolean | null;
  offered_at: string | null;
  offered_program: string | null;
  offered_start_date: string | null;
  offer_expires_at: string | null;
  offer_response: OfferResponse | null;
  offer_response_at: string | null;
  converted_application_id: string | null;
  source_url: string | null;
  source_campaign: string | null;
  inquiry_date: string;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface WaitlistEntryWithHistory extends WaitlistEntry {
  stage_history: StageHistoryRecord[];
  days_in_pipeline: number;
}

export interface StageHistoryRecord {
  id: string;
  from_stage: WaitlistStage | null;
  to_stage: WaitlistStage;
  changed_by: string | null;
  changed_by_name: string | null;
  notes: string | null;
  created_at: string;
}

// ============================================================
// Input Types
// ============================================================

export interface SubmitInquiryInput {
  tenant_id: string;
  child_first_name: string;
  child_last_name: string;
  child_date_of_birth: string;
  child_gender?: string | null;
  child_current_school?: string | null;
  requested_program?: string | null;
  requested_start?: string | null;
  requested_start_date?: string | null;
  parent_first_name: string;
  parent_last_name: string;
  parent_email: string;
  parent_phone?: string | null;
  siblings_at_school?: boolean;
  sibling_names?: string | null;
  how_heard_about_us?: string | null;
  notes?: string | null;
  source_url?: string | null;
  source_campaign?: string | null;
}

export interface UpdateWaitlistEntryInput {
  priority?: number;
  child_gender?: string | null;
  child_current_school?: string | null;
  requested_program?: string | null;
  requested_start?: string | null;
  requested_start_date?: string | null;
  parent_phone?: string | null;
  siblings_at_school?: boolean;
  sibling_names?: string | null;
  admin_notes?: string | null;
}

export interface TransitionStageInput {
  entry_id: string;
  to_stage: WaitlistStage;
  notes?: string | null;
}

export interface MakeOfferInput {
  entry_id: string;
  offered_program: string;
  offered_start_date: string;
  offer_expires_at?: string | null;
  notes?: string | null;
}

export interface ListWaitlistParams {
  stage?: WaitlistStage;
  requested_program?: string | null;
  search?: string;
  sort_by?: "priority" | "inquiry_date" | "child_last_name";
  sort_order?: "asc" | "desc";
  page?: number;
  per_page?: number;
}

// ============================================================
// SUBMIT INQUIRY (Public — no auth required)
// ============================================================
// Called from the public inquiry form at
// {school}.wattleos.au/inquiry. No authentication needed.
// Creates entry at 'inquiry' stage and logs the initial
// stage history record.
//
// WHY public insert: This is the school's digital front door.
// The RLS policy allows public inserts; the tenant_id is
// resolved from the subdomain at the page level.
// ============================================================

export async function submitInquiry(
  input: SubmitInquiryInput,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const supabase = await createSupabaseServerClient();

    // Validate required fields
    if (!input.parent_first_name?.trim()) {
      return failure(
        "Parent first name is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.parent_last_name?.trim()) {
      return failure(
        "Parent last name is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.parent_email?.trim()) {
      return failure("Parent email is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.child_first_name?.trim()) {
      return failure(
        "Child first name is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.child_last_name?.trim()) {
      return failure(
        "Child last name is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.child_date_of_birth) {
      return failure(
        "Child date of birth is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.tenant_id) {
      return failure(
        "School identifier is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check for duplicate inquiry (same email + child name + tenant)
    const { data: existing } = await supabase
      .from("waitlist_entries")
      .select("id, stage")
      .eq("tenant_id", input.tenant_id)
      .eq("parent_email", input.parent_email.trim().toLowerCase())
      .eq("child_first_name", input.child_first_name.trim())
      .eq("child_last_name", input.child_last_name.trim())
      .is("deleted_at", null)
      .not("stage", "in", '("declined","withdrawn")')
      .limit(1);

    if (existing && existing.length > 0) {
      return failure(
        "An inquiry for this child already exists. Please contact the school for an update.",
        ErrorCodes.ALREADY_EXISTS,
      );
    }

    const { data, error } = await supabase
      .from("waitlist_entries")
      .insert({
        tenant_id: input.tenant_id,
        stage: "inquiry" as WaitlistStage,
        priority: 0,
        child_first_name: input.child_first_name.trim(),
        child_last_name: input.child_last_name.trim(),
        child_date_of_birth: input.child_date_of_birth,
        child_gender: input.child_gender ?? null,
        child_current_school: input.child_current_school?.trim() ?? null,
        requested_program: input.requested_program ?? null,
        requested_start: input.requested_start?.trim() ?? null,
        requested_start_date: input.requested_start_date ?? null,
        parent_first_name: input.parent_first_name.trim(),
        parent_last_name: input.parent_last_name.trim(),
        parent_email: input.parent_email.trim().toLowerCase(),
        parent_phone: input.parent_phone?.trim() ?? null,
        siblings_at_school: input.siblings_at_school ?? false,
        sibling_names: input.sibling_names?.trim() ?? null,
        how_heard_about_us: input.how_heard_about_us?.trim() ?? null,
        notes: input.notes?.trim() ?? null,
        source_url: input.source_url ?? null,
        source_campaign: input.source_campaign ?? null,
        inquiry_date: new Date().toISOString().split("T")[0],
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    const entry = data as WaitlistEntry;

    // Log initial stage history
    await supabase.from("waitlist_stage_history").insert({
      tenant_id: input.tenant_id,
      waitlist_entry_id: entry.id,
      from_stage: null,
      to_stage: "inquiry",
      changed_by: null,
      notes: "Inquiry submitted via public form",
    });

    return success(entry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to submit inquiry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST WAITLIST ENTRIES (Admin pipeline view)
// ============================================================
// Permission: VIEW_WAITLIST or MANAGE_WAITLIST
// Supports filtering by stage (for kanban columns),
// program, and free-text search on names/email.
// ============================================================

export async function listWaitlistEntries(
  params: ListWaitlistParams = {},
): Promise<PaginatedResponse<WaitlistEntry>> {
  try {
    await requirePermission(Permissions.VIEW_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 50;
    const offset = (page - 1) * perPage;
    const sortBy = params.sort_by ?? "priority";
    const sortOrder = params.sort_order ?? "desc";

    // Count
    let countQuery = supabase
      .from("waitlist_entries")
      .select("id", { count: "exact", head: true })
      .is("deleted_at", null);

    if (params.stage) countQuery = countQuery.eq("stage", params.stage);
    if (params.requested_program)
      countQuery = countQuery.eq("requested_program", params.requested_program);
    if (params.search) {
      countQuery = countQuery.or(
        `child_first_name.ilike.%${params.search}%,child_last_name.ilike.%${params.search}%,parent_first_name.ilike.%${params.search}%,parent_last_name.ilike.%${params.search}%,parent_email.ilike.%${params.search}%`,
      );
    }

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    let query = supabase
      .from("waitlist_entries")
      .select("*")
      .is("deleted_at", null)
      .range(offset, offset + perPage - 1);

    if (params.stage) query = query.eq("stage", params.stage);
    if (params.requested_program)
      query = query.eq("requested_program", params.requested_program);
    if (params.search) {
      query = query.or(
        `child_first_name.ilike.%${params.search}%,child_last_name.ilike.%${params.search}%,parent_first_name.ilike.%${params.search}%,parent_last_name.ilike.%${params.search}%,parent_email.ilike.%${params.search}%`,
      );
    }

    // Sort
    switch (sortBy) {
      case "priority":
        query = query
          .order("priority", { ascending: sortOrder === "asc" })
          .order("inquiry_date", { ascending: true });
        break;
      case "inquiry_date":
        query = query.order("inquiry_date", { ascending: sortOrder === "asc" });
        break;
      case "child_last_name":
        query = query.order("child_last_name", {
          ascending: sortOrder === "asc",
        });
        break;
    }

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return paginated((data ?? []) as WaitlistEntry[], total, page, perPage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list waitlist entries";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SINGLE ENTRY (with stage history)
// ============================================================

export async function getWaitlistEntry(
  entryId: string,
): Promise<ActionResponse<WaitlistEntryWithHistory>> {
  try {
    await requirePermission(Permissions.VIEW_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const { data: entry, error } = await supabase
      .from("waitlist_entries")
      .select("*")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (error) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    // Get stage history with user names
    const { data: history } = await supabase
      .from("waitlist_stage_history")
      .select(
        `
        id, from_stage, to_stage, changed_by, notes, created_at,
        changed_by_user:users!waitlist_stage_history_changed_by_fkey(first_name, last_name)
      `,
      )
      .eq("waitlist_entry_id", entryId)
      .order("created_at", { ascending: false });

    const stageHistory: StageHistoryRecord[] = (
      (history ?? []) as Array<Record<string, unknown>>
    ).map((h) => {
      const user = h.changed_by_user as {
        first_name: string;
        last_name: string;
      } | null;
      return {
        id: h.id as string,
        from_stage: h.from_stage as WaitlistStage | null,
        to_stage: h.to_stage as WaitlistStage,
        changed_by: h.changed_by as string | null,
        changed_by_name: user ? `${user.first_name} ${user.last_name}` : null,
        notes: h.notes as string | null,
        created_at: h.created_at as string,
      };
    });

    const wl = entry as WaitlistEntry;
    const inquiryDate = new Date(wl.inquiry_date);
    const daysInPipeline = Math.floor(
      (Date.now() - inquiryDate.getTime()) / (1000 * 60 * 60 * 24),
    );

    return success({
      ...wl,
      stage_history: stageHistory,
      days_in_pipeline: daysInPipeline,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get waitlist entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE ENTRY (admin edits)
// ============================================================
// Permission: MANAGE_WAITLIST
// For editing priority, admin notes, child details, etc.
// Stage changes go through transitionStage() for audit.
// ============================================================

export async function updateWaitlistEntry(
  entryId: string,
  input: UpdateWaitlistEntryInput,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.priority !== undefined) updateData.priority = input.priority;
    if (input.child_gender !== undefined)
      updateData.child_gender = input.child_gender;
    if (input.child_current_school !== undefined)
      updateData.child_current_school = input.child_current_school;
    if (input.requested_program !== undefined)
      updateData.requested_program = input.requested_program;
    if (input.requested_start !== undefined)
      updateData.requested_start = input.requested_start;
    if (input.requested_start_date !== undefined)
      updateData.requested_start_date = input.requested_start_date;
    if (input.parent_phone !== undefined)
      updateData.parent_phone = input.parent_phone;
    if (input.siblings_at_school !== undefined)
      updateData.siblings_at_school = input.siblings_at_school;
    if (input.sibling_names !== undefined)
      updateData.sibling_names = input.sibling_names;
    if (input.admin_notes !== undefined)
      updateData.admin_notes = input.admin_notes;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("waitlist_entries")
      .update(updateData)
      .eq("id", entryId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as WaitlistEntry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// TRANSITION STAGE
// ============================================================
// Permission: MANAGE_WAITLIST
// Moves an entry to a new stage and logs the transition.
// Validates allowed transitions to prevent skipping steps.
// ============================================================

const ALLOWED_TRANSITIONS: Record<WaitlistStage, WaitlistStage[]> = {
  inquiry: ["waitlisted", "withdrawn"],
  waitlisted: ["tour_scheduled", "offered", "withdrawn"],
  tour_scheduled: ["tour_completed", "waitlisted", "withdrawn"],
  tour_completed: ["offered", "waitlisted", "withdrawn"],
  offered: ["accepted", "declined", "withdrawn"],
  accepted: ["enrolled", "withdrawn"],
  enrolled: [],
  declined: ["waitlisted"],
  withdrawn: ["inquiry"],
};

export async function transitionStage(
  input: TransitionStageInput,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    // Get current entry
    const { data: current, error: fetchError } = await supabase
      .from("waitlist_entries")
      .select("id, stage, tenant_id")
      .eq("id", input.entry_id)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = current as {
      id: string;
      stage: WaitlistStage;
      tenant_id: string;
    };

    // Validate transition
    const allowed = ALLOWED_TRANSITIONS[entry.stage];
    if (!allowed.includes(input.to_stage)) {
      return failure(
        `Cannot transition from '${entry.stage}' to '${input.to_stage}'. Allowed: ${allowed.join(", ") || "none"}`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Update stage
    const { data, error } = await supabase
      .from("waitlist_entries")
      .update({ stage: input.to_stage })
      .eq("id", input.entry_id)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    // Log transition
    await supabase.from("waitlist_stage_history").insert({
      tenant_id: entry.tenant_id,
      waitlist_entry_id: input.entry_id,
      from_stage: entry.stage,
      to_stage: input.to_stage,
      changed_by: context.user.id,
      notes: input.notes?.trim() ?? null,
    });

    // TODO: Check email_templates for trigger_stage matching
    // input.to_stage and auto-send if configured

    return success(data as WaitlistEntry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to transition stage";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// MAKE OFFER
// ============================================================
// Permission: MANAGE_WAITLIST
// Moves entry to 'offered' stage and records the offer
// details (program, start date, expiry).
// ============================================================

export async function makeOffer(
  input: MakeOfferInput,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    // Get current entry
    const { data: current, error: fetchError } = await supabase
      .from("waitlist_entries")
      .select("id, stage, tenant_id")
      .eq("id", input.entry_id)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = current as {
      id: string;
      stage: WaitlistStage;
      tenant_id: string;
    };

    // Can offer from waitlisted or tour_completed
    if (!["waitlisted", "tour_completed"].includes(entry.stage)) {
      return failure(
        `Cannot make offer from '${entry.stage}'. Entry must be 'waitlisted' or 'tour_completed'.`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    if (!input.offered_program?.trim()) {
      return failure(
        "Offered program is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.offered_start_date) {
      return failure(
        "Offered start date is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("waitlist_entries")
      .update({
        stage: "offered" as WaitlistStage,
        offered_at: new Date().toISOString(),
        offered_program: input.offered_program.trim(),
        offered_start_date: input.offered_start_date,
        offer_expires_at: input.offer_expires_at ?? null,
      })
      .eq("id", input.entry_id)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    // Log transition
    await supabase.from("waitlist_stage_history").insert({
      tenant_id: entry.tenant_id,
      waitlist_entry_id: input.entry_id,
      from_stage: entry.stage,
      to_stage: "offered",
      changed_by: context.user.id,
      notes:
        input.notes?.trim() ??
        `Offered ${input.offered_program} starting ${input.offered_start_date}`,
    });

    return success(data as WaitlistEntry);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to make offer";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// ACCEPT OFFER → CREATE ENROLLMENT APPLICATION
// ============================================================
// Permission: MANAGE_WAITLIST
// This is the bridge between Module 13 and Module 10.
// Creates a pre-filled enrollment application from the
// waitlist data, moves the entry to 'accepted', and links
// the two records via converted_application_id.
// ============================================================

export async function acceptOffer(
  entryId: string,
  enrollmentPeriodId: string,
): Promise<ActionResponse<{ entry: WaitlistEntry; application_id: string }>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    // Get full entry
    const { data: current, error: fetchError } = await supabase
      .from("waitlist_entries")
      .select("*")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = current as WaitlistEntry;

    if (entry.stage !== "offered") {
      return failure(
        `Cannot accept offer — entry is at '${entry.stage}', must be 'offered'`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check offer hasn't expired
    if (
      entry.offer_expires_at &&
      new Date(entry.offer_expires_at) < new Date()
    ) {
      return failure("This offer has expired", ErrorCodes.VALIDATION_ERROR);
    }

    // Create enrollment application (Module 10 bridge)
    const guardianData = [
      {
        first_name: entry.parent_first_name,
        last_name: entry.parent_last_name,
        email: entry.parent_email,
        phone: entry.parent_phone,
        relationship: "parent",
      },
    ];

    const { data: application, error: appError } = await supabase
      .from("enrollment_applications")
      .insert({
        tenant_id: entry.tenant_id,
        enrollment_period_id: enrollmentPeriodId,
        status: "submitted",
        submitted_by_email: entry.parent_email,
        submitted_by_user: entry.parent_user_id ?? null,
        submitted_at: new Date().toISOString(),
        child_first_name: entry.child_first_name,
        child_last_name: entry.child_last_name,
        child_date_of_birth: entry.child_date_of_birth,
        child_gender: entry.child_gender,
        child_previous_school: entry.child_current_school,
        requested_program: entry.offered_program ?? entry.requested_program,
        requested_start_date: entry.offered_start_date,
        guardians: guardianData,
      })
      .select("id")
      .single();

    if (appError) {
      return failure(
        `Failed to create enrollment application: ${appError.message}`,
        ErrorCodes.CREATE_FAILED,
      );
    }

    const applicationId = (application as { id: string }).id;

    // Update waitlist entry
    const { data: updated, error: updateError } = await supabase
      .from("waitlist_entries")
      .update({
        stage: "accepted" as WaitlistStage,
        offer_response: "accepted" as OfferResponse,
        offer_response_at: new Date().toISOString(),
        converted_application_id: applicationId,
      })
      .eq("id", entryId)
      .select()
      .single();

    if (updateError) {
      return failure(updateError.message, ErrorCodes.UPDATE_FAILED);
    }

    // Log transition
    await supabase.from("waitlist_stage_history").insert({
      tenant_id: entry.tenant_id,
      waitlist_entry_id: entryId,
      from_stage: "offered",
      to_stage: "accepted",
      changed_by: context.user.id,
      notes: `Offer accepted. Enrollment application ${applicationId} created.`,
    });

    return success({
      entry: updated as WaitlistEntry,
      application_id: applicationId,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to accept offer";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DECLINE OFFER
// ============================================================

export async function declineOffer(
  entryId: string,
  reason?: string,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const { data: current } = await supabase
      .from("waitlist_entries")
      .select("stage, tenant_id")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (!current) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = current as { stage: WaitlistStage; tenant_id: string };

    if (entry.stage !== "offered") {
      return failure(
        "Entry must be at offered stage to decline",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("waitlist_entries")
      .update({
        stage: "declined" as WaitlistStage,
        offer_response: "declined" as OfferResponse,
        offer_response_at: new Date().toISOString(),
      })
      .eq("id", entryId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    await supabase.from("waitlist_stage_history").insert({
      tenant_id: entry.tenant_id,
      waitlist_entry_id: entryId,
      from_stage: "offered",
      to_stage: "declined",
      changed_by: context.user.id,
      notes: reason?.trim() ?? "Offer declined",
    });

    return success(data as WaitlistEntry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to decline offer";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// WITHDRAW ENTRY
// ============================================================

export async function withdrawEntry(
  entryId: string,
  reason?: string,
): Promise<ActionResponse<WaitlistEntry>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const { data: current } = await supabase
      .from("waitlist_entries")
      .select("stage, tenant_id")
      .eq("id", entryId)
      .is("deleted_at", null)
      .single();

    if (!current) {
      return failure("Waitlist entry not found", ErrorCodes.NOT_FOUND);
    }

    const entry = current as { stage: WaitlistStage; tenant_id: string };

    if (["enrolled", "withdrawn"].includes(entry.stage)) {
      return failure(
        `Cannot withdraw — entry is already '${entry.stage}'`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("waitlist_entries")
      .update({ stage: "withdrawn" as WaitlistStage })
      .eq("id", entryId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    await supabase.from("waitlist_stage_history").insert({
      tenant_id: entry.tenant_id,
      waitlist_entry_id: entryId,
      from_stage: entry.stage,
      to_stage: "withdrawn",
      changed_by: context.user.id,
      notes: reason?.trim() ?? "Entry withdrawn",
    });

    return success(data as WaitlistEntry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to withdraw entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE ENTRY (soft delete)
// ============================================================

export async function deleteWaitlistEntry(
  entryId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(Permissions.MANAGE_WAITLIST);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("waitlist_entries")
      .update({ deleted_at: new Date().toISOString() })
      .eq("id", entryId)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CHECK INQUIRY STATUS (Public — by email + child name)
// ============================================================
// Returns a sanitized view of the entry for the parent.
// No admin notes, no internal fields.
// ============================================================

export async function checkInquiryStatus(
  tenantId: string,
  parentEmail: string,
  childFirstName: string,
  childLastName: string,
): Promise<
  ActionResponse<{
    stage: WaitlistStage;
    child_name: string;
    inquiry_date: string;
    days_waiting: number;
    tour_date: string | null;
    offered_program: string | null;
    offer_expires_at: string | null;
  } | null>
> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("waitlist_entries")
      .select(
        "stage, child_first_name, child_last_name, inquiry_date, tour_date, offered_program, offer_expires_at",
      )
      .eq("tenant_id", tenantId)
      .eq("parent_email", parentEmail.trim().toLowerCase())
      .eq("child_first_name", childFirstName.trim())
      .eq("child_last_name", childLastName.trim())
      .is("deleted_at", null)
      .limit(1)
      .single();

    if (error) {
      return success(null);
    }

    const entry = data as {
      stage: WaitlistStage;
      child_first_name: string;
      child_last_name: string;
      inquiry_date: string;
      tour_date: string | null;
      offered_program: string | null;
      offer_expires_at: string | null;
    };

    const daysWaiting = Math.floor(
      (Date.now() - new Date(entry.inquiry_date).getTime()) /
        (1000 * 60 * 60 * 24),
    );

    return success({
      stage: entry.stage,
      child_name: `${entry.child_first_name} ${entry.child_last_name}`,
      inquiry_date: entry.inquiry_date,
      days_waiting: daysWaiting,
      tour_date: entry.tour_date,
      offered_program: entry.offered_program,
      offer_expires_at: entry.offer_expires_at,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to check status";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// PIPELINE ANALYTICS
// ============================================================
// Permission: VIEW_ADMISSIONS_ANALYTICS
// Returns funnel metrics, demand by program, and average
// time per stage.
// ============================================================

export interface PipelineAnalytics {
  stage_counts: Record<WaitlistStage, number>;
  total_active: number;
  conversion_funnel: {
    inquiries: number;
    tours_completed: number;
    offers_made: number;
    offers_accepted: number;
    enrolled: number;
    conversion_rate_pct: number;
  };
  demand_by_program: Array<{
    program: string;
    count: number;
  }>;
  avg_days_per_stage: Record<string, number>;
  referral_sources: Array<{
    source: string;
    count: number;
  }>;
}

export async function getPipelineAnalytics(): Promise<
  ActionResponse<PipelineAnalytics>
> {
  try {
    await requirePermission(Permissions.VIEW_ADMISSIONS_ANALYTICS);
    const supabase = await createSupabaseServerClient();

    // Get all non-deleted entries
    const { data: entries, error } = await supabase
      .from("waitlist_entries")
      .select(
        "id, stage, requested_program, how_heard_about_us, inquiry_date, offered_at, offer_response_at",
      )
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    const allEntries = (entries ?? []) as Array<{
      id: string;
      stage: WaitlistStage;
      requested_program: string | null;
      how_heard_about_us: string | null;
      inquiry_date: string;
      offered_at: string | null;
      offer_response_at: string | null;
    }>;

    // Stage counts
    const stageCounts: Record<WaitlistStage, number> = {
      inquiry: 0,
      waitlisted: 0,
      tour_scheduled: 0,
      tour_completed: 0,
      offered: 0,
      accepted: 0,
      enrolled: 0,
      declined: 0,
      withdrawn: 0,
    };

    for (const e of allEntries) {
      stageCounts[e.stage]++;
    }

    const activeStages: WaitlistStage[] = [
      "inquiry",
      "waitlisted",
      "tour_scheduled",
      "tour_completed",
      "offered",
      "accepted",
    ];
    const totalActive = activeStages.reduce(
      (sum, s) => sum + stageCounts[s],
      0,
    );

    // Conversion funnel
    const totalInquiries = allEntries.length;
    const toursCompleted = allEntries.filter((e) =>
      [
        "tour_completed",
        "offered",
        "accepted",
        "enrolled",
        "declined",
      ].includes(e.stage),
    ).length;
    const offersMade = allEntries.filter((e) =>
      ["offered", "accepted", "enrolled", "declined"].includes(e.stage),
    ).length;
    const offersAccepted = allEntries.filter((e) =>
      ["accepted", "enrolled"].includes(e.stage),
    ).length;
    const enrolled = stageCounts.enrolled;

    // Demand by program
    const programMap = new Map<string, number>();
    for (const e of allEntries) {
      const prog = e.requested_program ?? "Unspecified";
      programMap.set(prog, (programMap.get(prog) ?? 0) + 1);
    }
    const demandByProgram = Array.from(programMap.entries())
      .map(([program, count]) => ({ program, count }))
      .sort((a, b) => b.count - a.count);

    // Referral sources
    const sourceMap = new Map<string, number>();
    for (const e of allEntries) {
      const src = e.how_heard_about_us ?? "Unknown";
      sourceMap.set(src, (sourceMap.get(src) ?? 0) + 1);
    }
    const referralSources = Array.from(sourceMap.entries())
      .map(([source, count]) => ({ source, count }))
      .sort((a, b) => b.count - a.count);

    // Average days per stage (from stage history)
    const { data: historyData } = await supabase
      .from("waitlist_stage_history")
      .select("waitlist_entry_id, from_stage, to_stage, created_at")
      .order("created_at", { ascending: true });

    const avgDaysPerStage: Record<string, number> = {};

    if (historyData && historyData.length > 0) {
      // Group transitions by entry
      const transitionsByEntry = new Map<
        string,
        Array<{
          from_stage: string | null;
          to_stage: string;
          created_at: string;
        }>
      >();

      for (const h of historyData as Array<{
        waitlist_entry_id: string;
        from_stage: string | null;
        to_stage: string;
        created_at: string;
      }>) {
        if (!transitionsByEntry.has(h.waitlist_entry_id)) {
          transitionsByEntry.set(h.waitlist_entry_id, []);
        }
        transitionsByEntry.get(h.waitlist_entry_id)!.push(h);
      }

      // Calculate time spent in each stage
      const stageDays = new Map<string, number[]>();

      for (const transitions of transitionsByEntry.values()) {
        for (let i = 0; i < transitions.length - 1; i++) {
          const stage = transitions[i].to_stage;
          const enterTime = new Date(transitions[i].created_at).getTime();
          const exitTime = new Date(transitions[i + 1].created_at).getTime();
          const days = (exitTime - enterTime) / (1000 * 60 * 60 * 24);

          if (!stageDays.has(stage)) stageDays.set(stage, []);
          stageDays.get(stage)!.push(days);
        }
      }

      for (const [stage, days] of stageDays.entries()) {
        avgDaysPerStage[stage] = Math.round(
          days.reduce((a, b) => a + b, 0) / days.length,
        );
      }
    }

    return success({
      stage_counts: stageCounts,
      total_active: totalActive,
      conversion_funnel: {
        inquiries: totalInquiries,
        tours_completed: toursCompleted,
        offers_made: offersMade,
        offers_accepted: offersAccepted,
        enrolled,
        conversion_rate_pct:
          totalInquiries > 0
            ? Math.round((enrolled / totalInquiries) * 100)
            : 0,
      },
      demand_by_program: demandByProgram,
      avg_days_per_stage: avgDaysPerStage,
      referral_sources: referralSources,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get analytics";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\comms\announcements.ts =====

// src/lib/actions/comms/announcements.ts
//
// ============================================================
// WattleOS V2 — Module 12: Enhanced Announcement Server Actions
// ============================================================
// Replaces the Module 7 announcements with the full Module 12
// schema: scheduling, expiry, program-scoped targeting,
// acknowledgement tracking, and pin management.
//
// WHY separate from old announcements.ts: The mega migration
// changed the schema significantly (scope enum, scheduled_for,
// requires_acknowledgement, announcement_acknowledgements).
// This file uses the new tables; the old file can be removed
// once the UI is migrated.
// ============================================================

'use server';

import { createSupabaseServerClient } from '@/lib/supabase/server';
import { getTenantContext, requirePermission } from '@/lib/auth/tenant-context';
import { Permissions } from '@/lib/constants/permissions';
import {
  ActionResponse,
  PaginatedResponse,
  success,
  failure,
  paginated,
  paginatedFailure,
  ErrorCodes,
} from '@/types/api';
import type { User, Class } from '@/types/domain';

// ============================================================
// Types
// ============================================================

export type AnnouncementPriority = 'low' | 'normal' | 'high' | 'urgent';
export type AnnouncementScope = 'school' | 'class' | 'program';

/** Attachment shape stored in the JSONB attachment_urls column */
export interface AnnouncementAttachment {
  name: string;
  url: string;
  mime_type: string;
}

/** Row shape matching the new mega-migration announcements table */
export interface Announcement {
  id: string;
  tenant_id: string;
  author_id: string;
  title: string;
  body: string;
  priority: AnnouncementPriority;
  scope: AnnouncementScope;
  target_class_id: string | null;
  target_program_id: string | null;
  published_at: string | null;
  scheduled_for: string | null;
  expires_at: string | null;
  attachment_urls: AnnouncementAttachment[];
  requires_acknowledgement: boolean;
  pin_to_top: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

/** Announcement enriched with author + target info + engagement stats */
export interface AnnouncementWithDetails extends Announcement {
  author: Pick<User, 'id' | 'first_name' | 'last_name' | 'avatar_url'>;
  target_class: Pick<Class, 'id' | 'name'> | null;
  acknowledgement_count: number;
  is_acknowledged: boolean;
}

export interface AnnouncementAcknowledgement {
  id: string;
  tenant_id: string;
  announcement_id: string;
  user_id: string;
  acknowledged_at: string;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateAnnouncementInput {
  title: string;
  body: string;
  priority: AnnouncementPriority;
  scope: AnnouncementScope;
  target_class_id?: string | null;
  target_program_id?: string | null;
  scheduled_for?: string | null;
  expires_at?: string | null;
  attachment_urls?: AnnouncementAttachment[];
  requires_acknowledgement?: boolean;
  pin_to_top?: boolean;
  /** If true, publish immediately. If false (or scheduled_for set), stays draft. */
  publish_now?: boolean;
}

export interface UpdateAnnouncementInput {
  title?: string;
  body?: string;
  priority?: AnnouncementPriority;
  scope?: AnnouncementScope;
  target_class_id?: string | null;
  target_program_id?: string | null;
  scheduled_for?: string | null;
  expires_at?: string | null;
  attachment_urls?: AnnouncementAttachment[];
  requires_acknowledgement?: boolean;
  pin_to_top?: boolean;
}

export interface ListAnnouncementsParams {
  scope?: AnnouncementScope;
  target_class_id?: string;
  priority?: AnnouncementPriority;
  pinned_only?: boolean;
  include_drafts?: boolean;
  include_expired?: boolean;
  page?: number;
  per_page?: number;
}

// ============================================================
// CREATE ANNOUNCEMENT
// ============================================================
// Permission: SEND_ANNOUNCEMENTS
// Creates an announcement. If publish_now is true or no
// scheduled_for is set, published_at = now(). Otherwise it
// stays as a draft with a scheduled publish time.
// ============================================================

export async function createAnnouncement(
  input: CreateAnnouncementInput
): Promise<ActionResponse<Announcement>> {
  try {
    const context = await requirePermission(Permissions.SEND_ANNOUNCEMENTS);
    const supabase = await createSupabaseServerClient();

    if (!input.title.trim()) {
      return failure('Title is required', ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.body.trim()) {
      return failure('Announcement body is required', ErrorCodes.VALIDATION_ERROR);
    }
    if (input.scope === 'class' && !input.target_class_id) {
      return failure(
        'A target class is required for class-scoped announcements',
        ErrorCodes.VALIDATION_ERROR
      );
    }
    if (input.scope === 'program' && !input.target_program_id) {
      return failure(
        'A target program is required for program-scoped announcements',
        ErrorCodes.VALIDATION_ERROR
      );
    }

    // Determine published_at: immediate, scheduled, or draft
    let publishedAt: string | null = null;
    if (input.publish_now && !input.scheduled_for) {
      publishedAt = new Date().toISOString();
    }

    const { data, error } = await supabase
      .from('announcements')
      .insert({
        tenant_id: context.tenant.id,
        author_id: context.user.id,
        title: input.title.trim(),
        body: input.body.trim(),
        priority: input.priority,
        scope: input.scope,
        target_class_id: input.scope === 'class' ? input.target_class_id : null,
        target_program_id: input.scope === 'program' ? input.target_program_id : null,
        published_at: publishedAt,
        scheduled_for: input.scheduled_for ?? null,
        expires_at: input.expires_at ?? null,
        attachment_urls: JSON.stringify(input.attachment_urls ?? []),
        requires_acknowledgement: input.requires_acknowledgement ?? false,
        pin_to_top: input.pin_to_top ?? false,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as Announcement);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to create announcement';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE ANNOUNCEMENT
// ============================================================
// Permission: SEND_ANNOUNCEMENTS
// Partial update. Only provided fields are modified.
// ============================================================

export async function updateAnnouncement(
  announcementId: string,
  input: UpdateAnnouncementInput
): Promise<ActionResponse<Announcement>> {
  try {
    await requirePermission(Permissions.SEND_ANNOUNCEMENTS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.title !== undefined) updateData.title = input.title.trim();
    if (input.body !== undefined) updateData.body = input.body.trim();
    if (input.priority !== undefined) updateData.priority = input.priority;
    if (input.scope !== undefined) updateData.scope = input.scope;
    if (input.target_class_id !== undefined) updateData.target_class_id = input.target_class_id;
    if (input.target_program_id !== undefined) updateData.target_program_id = input.target_program_id;
    if (input.scheduled_for !== undefined) updateData.scheduled_for = input.scheduled_for;
    if (input.expires_at !== undefined) updateData.expires_at = input.expires_at;
    if (input.attachment_urls !== undefined) updateData.attachment_urls = JSON.stringify(input.attachment_urls);
    if (input.requires_acknowledgement !== undefined) updateData.requires_acknowledgement = input.requires_acknowledgement;
    if (input.pin_to_top !== undefined) updateData.pin_to_top = input.pin_to_top;

    if (Object.keys(updateData).length === 0) {
      return failure('No fields to update', ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from('announcements')
      .update(updateData)
      .eq('id', announcementId)
      .is('deleted_at', null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as Announcement);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to update announcement';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// PUBLISH ANNOUNCEMENT
// ============================================================
// Moves a draft to published. Sets published_at = now().
// Clears scheduled_for since it's being published manually.
// ============================================================

export async function publishAnnouncement(
  announcementId: string
): Promise<ActionResponse<Announcement>> {
  try {
    await requirePermission(Permissions.SEND_ANNOUNCEMENTS);
    const supabase = await createSupabaseServerClient();

    // Verify it's currently unpublished
    const { data: existing, error: fetchError } = await supabase
      .from('announcements')
      .select('id, published_at')
      .eq('id', announcementId)
      .is('deleted_at', null)
      .single();

    if (fetchError || !existing) {
      return failure('Announcement not found', ErrorCodes.NOT_FOUND);
    }

    if ((existing as { published_at: string | null }).published_at) {
      return failure('Announcement is already published', ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from('announcements')
      .update({
        published_at: new Date().toISOString(),
        scheduled_for: null,
      })
      .eq('id', announcementId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as Announcement);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to publish announcement';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE ANNOUNCEMENT (soft delete)
// ============================================================

export async function deleteAnnouncement(
  announcementId: string
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(Permissions.SEND_ANNOUNCEMENTS);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from('announcements')
      .update({ deleted_at: new Date().toISOString() })
      .eq('id', announcementId)
      .is('deleted_at', null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to delete announcement';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST ANNOUNCEMENTS (Staff view — paginated)
// ============================================================
// Returns announcements with author info, acknowledgement
// counts, ordered by pinned first → published_at descending.
// Permission: SEND_ANNOUNCEMENTS
// ============================================================

export async function listAnnouncements(
  params: ListAnnouncementsParams = {}
): Promise<PaginatedResponse<AnnouncementWithDetails>> {
  try {
    const context = await requirePermission(Permissions.SEND_ANNOUNCEMENTS);
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 25;
    const offset = (page - 1) * perPage;

    // Count query
    let countQuery = supabase
      .from('announcements')
      .select('id', { count: 'exact', head: true })
      .is('deleted_at', null);

    if (!params.include_drafts) {
      countQuery = countQuery.not('published_at', 'is', null);
    }
    if (!params.include_expired) {
      countQuery = countQuery.or('expires_at.is.null,expires_at.gt.now()');
    }
    if (params.scope) {
      countQuery = countQuery.eq('scope', params.scope);
    }
    if (params.target_class_id) {
      countQuery = countQuery.eq('target_class_id', params.target_class_id);
    }
    if (params.priority) {
      countQuery = countQuery.eq('priority', params.priority);
    }
    if (params.pinned_only) {
      countQuery = countQuery.eq('pin_to_top', true);
    }

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data query
    let query = supabase
      .from('announcements')
      .select(
        `
        *,
        author:users!announcements_author_id_fkey(id, first_name, last_name, avatar_url),
        target_class:classes!announcements_target_class_id_fkey(id, name),
        announcement_acknowledgements(id)
      `
      )
      .is('deleted_at', null)
      .order('pin_to_top', { ascending: false })
      .order('published_at', { ascending: false, nullsFirst: false })
      .range(offset, offset + perPage - 1);

    if (!params.include_drafts) {
      query = query.not('published_at', 'is', null);
    }
    if (!params.include_expired) {
      query = query.or('expires_at.is.null,expires_at.gt.now()');
    }
    if (params.scope) {
      query = query.eq('scope', params.scope);
    }
    if (params.target_class_id) {
      query = query.eq('target_class_id', params.target_class_id);
    }
    if (params.priority) {
      query = query.eq('priority', params.priority);
    }
    if (params.pinned_only) {
      query = query.eq('pin_to_top', true);
    }

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Check which the current user has acknowledged
    const announcementIds = ((data ?? []) as Array<{ id: string }>).map((a) => a.id);
    let ackSet = new Set<string>();

    if (announcementIds.length > 0) {
      const { data: acks } = await supabase
        .from('announcement_acknowledgements')
        .select('announcement_id')
        .eq('user_id', context.user.id)
        .in('announcement_id', announcementIds);

      ackSet = new Set(
        (acks ?? []).map((a) => (a as { announcement_id: string }).announcement_id)
      );
    }

    const announcements: AnnouncementWithDetails[] = ((data ?? []) as Array<Record<string, unknown>>).map(
      (row) => ({
        // Base fields
        id: row.id as string,
        tenant_id: row.tenant_id as string,
        author_id: row.author_id as string,
        title: row.title as string,
        body: row.body as string,
        priority: row.priority as AnnouncementPriority,
        scope: row.scope as AnnouncementScope,
        target_class_id: row.target_class_id as string | null,
        target_program_id: row.target_program_id as string | null,
        published_at: row.published_at as string | null,
        scheduled_for: row.scheduled_for as string | null,
        expires_at: row.expires_at as string | null,
        attachment_urls: (row.attachment_urls ?? []) as AnnouncementAttachment[],
        requires_acknowledgement: row.requires_acknowledgement as boolean,
        pin_to_top: row.pin_to_top as boolean,
        created_at: row.created_at as string,
        updated_at: row.updated_at as string,
        deleted_at: row.deleted_at as string | null,
        // Enrichments
        author: row.author as Pick<User, 'id' | 'first_name' | 'last_name' | 'avatar_url'>,
        target_class: row.target_class as Pick<Class, 'id' | 'name'> | null,
        acknowledgement_count: Array.isArray(row.announcement_acknowledgements)
          ? (row.announcement_acknowledgements as Array<unknown>).length
          : 0,
        is_acknowledged: ackSet.has(row.id as string),
      })
    );

    return paginated(announcements, total, page, perPage);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to list announcements';
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET ANNOUNCEMENTS FOR PARENT
// ============================================================
// Returns published, non-expired announcements visible to
// the current parent based on their children's class enrollments
// and program bookings. No permission required (authenticated).
// ============================================================

export async function getAnnouncementsForParent(
  params: { page?: number; per_page?: number } = {}
): Promise<PaginatedResponse<AnnouncementWithDetails>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 25;
    const offset = (page - 1) * perPage;

    // Resolve parent's class IDs via guardian → student → enrollment
    const { data: guardianships } = await supabase
      .from('guardians')
      .select('student_id')
      .eq('user_id', context.user.id)
      .is('deleted_at', null);

    const studentIds = (guardianships ?? []).map(
      (g) => (g as { student_id: string }).student_id
    );

    let classIds: string[] = [];
    if (studentIds.length > 0) {
      const { data: enrollments } = await supabase
        .from('enrollments')
        .select('class_id')
        .in('student_id', studentIds)
        .eq('status', 'active')
        .is('deleted_at', null);

      classIds = [
        ...new Set(
          (enrollments ?? []).map((e) => (e as { class_id: string }).class_id)
        ),
      ];
    }

    // Build OR filter: school-wide OR class-targeted for parent's classes
    let scopeFilter: string;
    if (classIds.length > 0) {
      scopeFilter = `scope.eq.school,target_class_id.in.(${classIds.join(',')})`;
    } else {
      scopeFilter = 'scope.eq.school';
    }

    // Count
    const { count, error: countError } = await supabase
      .from('announcements')
      .select('id', { count: 'exact', head: true })
      .is('deleted_at', null)
      .not('published_at', 'is', null)
      .lte('published_at', new Date().toISOString())
      .or('expires_at.is.null,expires_at.gt.now()')
      .or(scopeFilter);

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    const { data, error } = await supabase
      .from('announcements')
      .select(
        `
        *,
        author:users!announcements_author_id_fkey(id, first_name, last_name, avatar_url),
        target_class:classes!announcements_target_class_id_fkey(id, name),
        announcement_acknowledgements(id)
      `
      )
      .is('deleted_at', null)
      .not('published_at', 'is', null)
      .lte('published_at', new Date().toISOString())
      .or('expires_at.is.null,expires_at.gt.now()')
      .or(scopeFilter)
      .order('pin_to_top', { ascending: false })
      .order('published_at', { ascending: false })
      .range(offset, offset + perPage - 1);

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Acknowledged status for current user
    const announcementIds = ((data ?? []) as Array<{ id: string }>).map((a) => a.id);
    let ackSet = new Set<string>();

    if (announcementIds.length > 0) {
      const { data: acks } = await supabase
        .from('announcement_acknowledgements')
        .select('announcement_id')
        .eq('user_id', context.user.id)
        .in('announcement_id', announcementIds);

      ackSet = new Set(
        (acks ?? []).map((a) => (a as { announcement_id: string }).announcement_id)
      );
    }

    const announcements: AnnouncementWithDetails[] = ((data ?? []) as Array<Record<string, unknown>>).map(
      (row) => ({
        id: row.id as string,
        tenant_id: row.tenant_id as string,
        author_id: row.author_id as string,
        title: row.title as string,
        body: row.body as string,
        priority: row.priority as AnnouncementPriority,
        scope: row.scope as AnnouncementScope,
        target_class_id: row.target_class_id as string | null,
        target_program_id: row.target_program_id as string | null,
        published_at: row.published_at as string | null,
        scheduled_for: row.scheduled_for as string | null,
        expires_at: row.expires_at as string | null,
        attachment_urls: (row.attachment_urls ?? []) as AnnouncementAttachment[],
        requires_acknowledgement: row.requires_acknowledgement as boolean,
        pin_to_top: row.pin_to_top as boolean,
        created_at: row.created_at as string,
        updated_at: row.updated_at as string,
        deleted_at: row.deleted_at as string | null,
        author: row.author as Pick<User, 'id' | 'first_name' | 'last_name' | 'avatar_url'>,
        target_class: row.target_class as Pick<Class, 'id' | 'name'> | null,
        acknowledgement_count: Array.isArray(row.announcement_acknowledgements)
          ? (row.announcement_acknowledgements as Array<unknown>).length
          : 0,
        is_acknowledged: ackSet.has(row.id as string),
      })
    );

    return paginated(announcements, total, page, perPage);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to get announcements';
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// ACKNOWLEDGE ANNOUNCEMENT
// ============================================================
// Idempotent upsert on (tenant_id, announcement_id, user_id).
// Any authenticated tenant member can acknowledge.
// ============================================================

export async function acknowledgeAnnouncement(
  announcementId: string
): Promise<ActionResponse<AnnouncementAcknowledgement>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from('announcement_acknowledgements')
      .upsert(
        {
          tenant_id: context.tenant.id,
          announcement_id: announcementId,
          user_id: context.user.id,
          acknowledged_at: new Date().toISOString(),
        },
        { onConflict: 'tenant_id,announcement_id,user_id' }
      )
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success(data as AnnouncementAcknowledgement);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to acknowledge announcement';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET ACKNOWLEDGEMENT STATS
// ============================================================
// Staff view: who acknowledged, who hasn't. Useful for
// urgent announcements requiring parent confirmation.
// Permission: SEND_ANNOUNCEMENTS
// ============================================================

export interface AcknowledgementStats {
  total_acknowledged: number;
  acknowledgers: Array<
    Pick<User, 'id' | 'first_name' | 'last_name'> & { acknowledged_at: string }
  >;
}

export async function getAcknowledgementStats(
  announcementId: string
): Promise<ActionResponse<AcknowledgementStats>> {
  try {
    await requirePermission(Permissions.SEND_ANNOUNCEMENTS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from('announcement_acknowledgements')
      .select(
        `
        acknowledged_at,
        user:users!announcement_acknowledgements_user_id_fkey(id, first_name, last_name)
      `
      )
      .eq('announcement_id', announcementId)
      .order('acknowledged_at', { ascending: false });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    const acknowledgers = ((data ?? []) as Array<Record<string, unknown>>).map((row) => ({
      ...(row.user as Pick<User, 'id' | 'first_name' | 'last_name'>),
      acknowledged_at: row.acknowledged_at as string,
    }));

    return success({
      total_acknowledged: acknowledgers.length,
      acknowledgers,
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to get acknowledgement stats';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET UNREAD / UNACKNOWLEDGED COUNT
// ============================================================
// For notification badge. Counts published announcements the
// current user hasn't acknowledged (where requires_acknowledgement
// is true) plus totally unviewed ones.
// ============================================================

export async function getUnacknowledgedCount(): Promise<ActionResponse<number>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Get parent's class IDs
    const { data: guardianships } = await supabase
      .from('guardians')
      .select('student_id')
      .eq('user_id', context.user.id)
      .is('deleted_at', null);

    const studentIds = (guardianships ?? []).map(
      (g) => (g as { student_id: string }).student_id
    );

    let classIds: string[] = [];
    if (studentIds.length > 0) {
      const { data: enrollments } = await supabase
        .from('enrollments')
        .select('class_id')
        .in('student_id', studentIds)
        .eq('status', 'active')
        .is('deleted_at', null);

      classIds = [
        ...new Set(
          (enrollments ?? []).map((e) => (e as { class_id: string }).class_id)
        ),
      ];
    }

    // Get all visible announcements requiring acknowledgement
    let scopeFilter: string;
    if (classIds.length > 0) {
      scopeFilter = `scope.eq.school,target_class_id.in.(${classIds.join(',')})`;
    } else {
      scopeFilter = 'scope.eq.school';
    }

    const { data: allAnnouncements } = await supabase
      .from('announcements')
      .select('id')
      .is('deleted_at', null)
      .not('published_at', 'is', null)
      .lte('published_at', new Date().toISOString())
      .or('expires_at.is.null,expires_at.gt.now()')
      .eq('requires_acknowledgement', true)
      .or(scopeFilter);

    const allIds = ((allAnnouncements ?? []) as Array<{ id: string }>).map((a) => a.id);

    if (allIds.length === 0) {
      return success(0);
    }

    // Which ones has the user acknowledged?
    const { data: acks } = await supabase
      .from('announcement_acknowledgements')
      .select('announcement_id')
      .eq('user_id', context.user.id)
      .in('announcement_id', allIds);

    const ackSet = new Set(
      (acks ?? []).map((a) => (a as { announcement_id: string }).announcement_id)
    );

    const unacknowledgedCount = allIds.filter((id) => !ackSet.has(id)).length;

    return success(unacknowledgedCount);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to get unacknowledged count';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SINGLE ANNOUNCEMENT
// ============================================================
// Returns a single announcement with full details. Accessible
// by any authenticated tenant member (RLS handles scoping).
// ============================================================

export async function getAnnouncement(
  announcementId: string
): Promise<ActionResponse<AnnouncementWithDetails>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from('announcements')
      .select(
        `
        *,
        author:users!announcements_author_id_fkey(id, first_name, last_name, avatar_url),
        target_class:classes!announcements_target_class_id_fkey(id, name),
        announcement_acknowledgements(id)
      `
      )
      .eq('id', announcementId)
      .is('deleted_at', null)
      .single();

    if (error) {
      return failure('Announcement not found', ErrorCodes.NOT_FOUND);
    }

    const row = data as Record<string, unknown>;

    // Check if current user has acknowledged
    const { data: acks } = await supabase
      .from('announcement_acknowledgements')
      .select('id')
      .eq('announcement_id', announcementId)
      .eq('user_id', context.user.id)
      .limit(1);

    const announcement: AnnouncementWithDetails = {
      id: row.id as string,
      tenant_id: row.tenant_id as string,
      author_id: row.author_id as string,
      title: row.title as string,
      body: row.body as string,
      priority: row.priority as AnnouncementPriority,
      scope: row.scope as AnnouncementScope,
      target_class_id: row.target_class_id as string | null,
      target_program_id: row.target_program_id as string | null,
      published_at: row.published_at as string | null,
      scheduled_for: row.scheduled_for as string | null,
      expires_at: row.expires_at as string | null,
      attachment_urls: (row.attachment_urls ?? []) as AnnouncementAttachment[],
      requires_acknowledgement: row.requires_acknowledgement as boolean,
      pin_to_top: row.pin_to_top as boolean,
      created_at: row.created_at as string,
      updated_at: row.updated_at as string,
      deleted_at: row.deleted_at as string | null,
      author: row.author as Pick<User, 'id' | 'first_name' | 'last_name' | 'avatar_url'>,
      target_class: row.target_class as Pick<Class, 'id' | 'name'> | null,
      acknowledgement_count: Array.isArray(row.announcement_acknowledgements)
        ? (row.announcement_acknowledgements as Array<unknown>).length
        : 0,
      is_acknowledged: (acks ?? []).length > 0,
    };

    return success(announcement);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to get announcement';
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\comms\chat-channels.ts =====

// src/lib/actions/comms/chat-channels.ts
//
// ============================================================
// WattleOS V2 — Module 12: Chat Channel Server Actions
// ============================================================
// Manages the new chat_channels / chat_channel_members /
// chat_messages tables from the mega migration. Supports:
//   • class_group — auto-populated from enrollment + guardians
//   • program_group — auto-populated from program bookings
//   • direct — 1:1 between any two tenant members
//   • staff — staff-only channels
//
// WHY channels not threads: Threads (Module 7) were ephemeral
// broadcast-and-reply. Channels are persistent group spaces
// with real-time subscriptions, read cursors, and moderation.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type { User } from "@/types/domain";

// ============================================================
// Types
// ============================================================

export type ChannelType = "class_group" | "program_group" | "direct" | "staff";
export type ChannelMemberRole = "owner" | "admin" | "member" | "read_only";
export type ChatMessageType = "text" | "image" | "file" | "system";

export interface ChatChannel {
  id: string;
  tenant_id: string;
  channel_type: ChannelType;
  name: string | null;
  class_id: string | null;
  program_id: string | null;
  created_by: string;
  is_active: boolean;
  allow_parent_posts: boolean;
  is_moderated: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface ChatChannelWithPreview extends ChatChannel {
  member_count: number;
  unread_count: number;
  last_message: {
    id: string;
    content: string;
    sender_name: string;
    created_at: string;
  } | null;
}

export interface ChatChannelMember {
  id: string;
  tenant_id: string;
  channel_id: string;
  user_id: string;
  role: ChannelMemberRole;
  muted: boolean;
  last_read_at: string | null;
  joined_at: string;
}

export interface ChatMessage {
  id: string;
  tenant_id: string;
  channel_id: string;
  sender_id: string;
  content: string;
  message_type: ChatMessageType;
  attachment_url: string | null;
  attachment_name: string | null;
  reply_to_id: string | null;
  is_hidden: boolean;
  hidden_by: string | null;
  hidden_reason: string | null;
  edited_at: string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface ChatMessageWithSender extends ChatMessage {
  sender: Pick<User, "id" | "first_name" | "last_name" | "avatar_url">;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateChannelInput {
  channel_type: ChannelType;
  name?: string | null;
  class_id?: string | null;
  program_id?: string | null;
  allow_parent_posts?: boolean;
  is_moderated?: boolean;
}

export interface SendMessageInput {
  channel_id: string;
  content: string;
  message_type?: ChatMessageType;
  attachment_url?: string | null;
  attachment_name?: string | null;
  reply_to_id?: string | null;
}

export interface ListMessagesParams {
  channel_id: string;
  before?: string; // cursor: created_at of oldest loaded message
  limit?: number;
}

// ============================================================
// CREATE CHANNEL
// ============================================================
// Permission: SEND_CLASS_MESSAGES (for class_group/program_group)
//             MODERATE_CHAT (for staff channels)
//             Any authenticated user (for direct messages)
//
// WHY auto-populate class groups: When a class_group channel is
// created, we pull all guides assigned to the class + all
// guardians of actively enrolled students. This ensures the
// channel roster stays current with enrollments.
// ============================================================

export async function createChannel(
  input: CreateChannelInput,
): Promise<ActionResponse<ChatChannel>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Permission checks based on channel type
    if (
      input.channel_type === "class_group" ||
      input.channel_type === "program_group"
    ) {
      await requirePermission(Permissions.SEND_CLASS_MESSAGES);
    }
    if (input.channel_type === "staff") {
      await requirePermission(Permissions.MODERATE_CHAT);
    }

    // Validation
    if (input.channel_type === "class_group" && !input.class_id) {
      return failure(
        "class_id is required for class group channels",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (input.channel_type === "program_group" && !input.program_id) {
      return failure(
        "program_id is required for program group channels",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check for existing class_group channel to prevent duplicates
    if (input.channel_type === "class_group" && input.class_id) {
      const { data: existing } = await supabase
        .from("chat_channels")
        .select("id")
        .eq("channel_type", "class_group")
        .eq("class_id", input.class_id)
        .is("deleted_at", null)
        .limit(1);

      if (existing && existing.length > 0) {
        return failure(
          "A class group channel already exists for this class",
          ErrorCodes.ALREADY_EXISTS,
        );
      }
    }

    const { data, error } = await supabase
      .from("chat_channels")
      .insert({
        tenant_id: context.tenant.id,
        channel_type: input.channel_type,
        name: input.name?.trim() ?? null,
        class_id: input.channel_type === "class_group" ? input.class_id : null,
        program_id:
          input.channel_type === "program_group" ? input.program_id : null,
        created_by: context.user.id,
        is_active: true,
        allow_parent_posts: input.allow_parent_posts ?? true,
        is_moderated: input.is_moderated ?? false,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    const channel = data as ChatChannel;

    // Add creator as owner
    await supabase.from("chat_channel_members").insert({
      tenant_id: context.tenant.id,
      channel_id: channel.id,
      user_id: context.user.id,
      role: "owner" as ChannelMemberRole,
    });

    // Auto-populate class group members
    if (input.channel_type === "class_group" && input.class_id) {
      await populateClassGroupMembers(
        supabase,
        context.tenant.id,
        channel.id,
        input.class_id,
      );
    }

    return success(channel);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create channel";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// POPULATE CLASS GROUP MEMBERS (internal helper)
// ============================================================
// Adds all guardians of actively-enrolled students to the
// channel. Skips users who are already members.
// ============================================================

async function populateClassGroupMembers(
  supabase: Awaited<ReturnType<typeof createSupabaseServerClient>>,
  tenantId: string,
  channelId: string,
  classId: string,
): Promise<void> {
  // Get all actively-enrolled student IDs in this class
  const { data: enrollments } = await supabase
    .from("enrollments")
    .select("student_id")
    .eq("class_id", classId)
    .eq("status", "active")
    .is("deleted_at", null);

  const studentIds = (enrollments ?? []).map(
    (e) => (e as { student_id: string }).student_id,
  );

  if (studentIds.length === 0) return;

  // Get all guardian user IDs for those students
  const { data: guardians } = await supabase
    .from("guardians")
    .select("user_id")
    .in("student_id", studentIds)
    .is("deleted_at", null);

  const guardianUserIds = [
    ...new Set(
      (guardians ?? [])
        .map((g) => (g as { user_id: string | null }).user_id)
        .filter((uid): uid is string => uid !== null),
    ),
  ];

  if (guardianUserIds.length === 0) return;

  // Get existing members to avoid duplicates
  const { data: existingMembers } = await supabase
    .from("chat_channel_members")
    .select("user_id")
    .eq("channel_id", channelId);

  const existingSet = new Set(
    (existingMembers ?? []).map((m) => (m as { user_id: string }).user_id),
  );

  // Insert new members
  const newMembers = guardianUserIds
    .filter((uid) => !existingSet.has(uid))
    .map((uid) => ({
      tenant_id: tenantId,
      channel_id: channelId,
      user_id: uid,
      role: "member" as ChannelMemberRole,
    }));

  if (newMembers.length > 0) {
    await supabase.from("chat_channel_members").insert(newMembers);
  }
}

// ============================================================
// CREATE DIRECT MESSAGE CHANNEL
// ============================================================
// Creates or retrieves an existing DM channel between the
// current user and the target user. Idempotent: if a DM
// channel already exists between the pair, returns it.
// ============================================================

export async function getOrCreateDirectChannel(
  targetUserId: string,
): Promise<ActionResponse<ChatChannel>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (targetUserId === context.user.id) {
      return failure(
        "Cannot create a DM channel with yourself",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check for existing DM channel between these two users
    const { data: existingChannels } = await supabase
      .from("chat_channels")
      .select(
        `
        id,
        chat_channel_members!inner(user_id)
      `,
      )
      .eq("channel_type", "direct")
      .is("deleted_at", null);

    // Find a channel where both users are members
    if (existingChannels) {
      for (const ch of existingChannels as Array<Record<string, unknown>>) {
        const members = ch.chat_channel_members as Array<{ user_id: string }>;
        const memberIds = new Set(members.map((m) => m.user_id));
        if (
          memberIds.has(context.user.id) &&
          memberIds.has(targetUserId) &&
          memberIds.size === 2
        ) {
          // Return existing DM channel
          const { data: fullChannel, error: fetchError } = await supabase
            .from("chat_channels")
            .select()
            .eq("id", ch.id as string)
            .single();

          if (!fetchError && fullChannel) {
            return success(fullChannel as ChatChannel);
          }
        }
      }
    }

    // Create new DM channel
    const { data: newChannel, error: createError } = await supabase
      .from("chat_channels")
      .insert({
        tenant_id: context.tenant.id,
        channel_type: "direct" as ChannelType,
        name: null,
        created_by: context.user.id,
        is_active: true,
        allow_parent_posts: true,
        is_moderated: false,
      })
      .select()
      .single();

    if (createError || !newChannel) {
      return failure(
        createError?.message ?? "Failed to create DM channel",
        ErrorCodes.CREATE_FAILED,
      );
    }

    const channel = newChannel as ChatChannel;

    // Add both users as members
    await supabase.from("chat_channel_members").insert([
      {
        tenant_id: context.tenant.id,
        channel_id: channel.id,
        user_id: context.user.id,
        role: "member" as ChannelMemberRole,
      },
      {
        tenant_id: context.tenant.id,
        channel_id: channel.id,
        user_id: targetUserId,
        role: "member" as ChannelMemberRole,
      },
    ]);

    return success(channel);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get or create DM channel";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE CHANNEL SETTINGS
// ============================================================
// Permission: MODERATE_CHAT or channel owner
// ============================================================

export async function updateChannel(
  channelId: string,
  input: {
    name?: string | null;
    allow_parent_posts?: boolean;
    is_moderated?: boolean;
    is_active?: boolean;
  },
): Promise<ActionResponse<ChatChannel>> {
  try {
    await requirePermission(Permissions.MODERATE_CHAT);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.name !== undefined) updateData.name = input.name?.trim() ?? null;
    if (input.allow_parent_posts !== undefined)
      updateData.allow_parent_posts = input.allow_parent_posts;
    if (input.is_moderated !== undefined)
      updateData.is_moderated = input.is_moderated;
    if (input.is_active !== undefined) updateData.is_active = input.is_active;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("chat_channels")
      .update(updateData)
      .eq("id", channelId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as ChatChannel);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update channel";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST USER'S CHANNELS
// ============================================================
// Returns all channels the current user is a member of,
// with unread counts and last message preview.
// ============================================================

export async function listMyChannels(): Promise<
  ActionResponse<ChatChannelWithPreview[]>
> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Get all channel IDs the user is a member of
    const { data: memberships, error: memberError } = await supabase
      .from("chat_channel_members")
      .select("channel_id, last_read_at")
      .eq("user_id", context.user.id);

    if (memberError) {
      return failure(memberError.message, ErrorCodes.DATABASE_ERROR);
    }

    if (!memberships || memberships.length === 0) {
      return success([]);
    }

    const membershipMap = new Map(
      (
        memberships as Array<{
          channel_id: string;
          last_read_at: string | null;
        }>
      ).map((m) => [m.channel_id, m.last_read_at]),
    );
    const channelIds = [...membershipMap.keys()];

    // Fetch channels with member counts
    const { data: channels, error: channelError } = await supabase
      .from("chat_channels")
      .select(
        `
        *,
        chat_channel_members(id)
      `,
      )
      .in("id", channelIds)
      .eq("is_active", true)
      .is("deleted_at", null)
      .order("updated_at", { ascending: false });

    if (channelError) {
      return failure(channelError.message, ErrorCodes.DATABASE_ERROR);
    }

    // Fetch last message for each channel
    const channelPreviews: ChatChannelWithPreview[] = [];

    for (const ch of (channels ?? []) as Array<Record<string, unknown>>) {
      const chId = ch.id as string;
      const lastReadAt = membershipMap.get(chId) ?? null;

      // Last message
      const { data: lastMsgData } = await supabase
        .from("chat_messages")
        .select(
          `
          id, content, created_at,
          sender:users!chat_messages_sender_id_fkey(first_name, last_name)
        `,
        )
        .eq("channel_id", chId)
        .is("deleted_at", null)
        .eq("is_hidden", false)
        .order("created_at", { ascending: false })
        .limit(1);

      let lastMessage: ChatChannelWithPreview["last_message"] = null;
      if (lastMsgData && lastMsgData.length > 0) {
        const msg = lastMsgData[0] as Record<string, unknown>;
        const sender = msg.sender as {
          first_name: string | null;
          last_name: string | null;
        } | null;
        lastMessage = {
          id: msg.id as string,
          content: msg.content as string,
          sender_name: sender
            ? `${sender.first_name ?? ""} ${sender.last_name ?? ""}`.trim()
            : "Unknown",
          created_at: msg.created_at as string,
        };
      }

      // Unread count
      let unreadCount = 0;
      if (lastReadAt) {
        const { count } = await supabase
          .from("chat_messages")
          .select("id", { count: "exact", head: true })
          .eq("channel_id", chId)
          .is("deleted_at", null)
          .eq("is_hidden", false)
          .gt("created_at", lastReadAt)
          .neq("sender_id", context.user.id);

        unreadCount = count ?? 0;
      } else {
        // Never read — all messages are unread
        const { count } = await supabase
          .from("chat_messages")
          .select("id", { count: "exact", head: true })
          .eq("channel_id", chId)
          .is("deleted_at", null)
          .eq("is_hidden", false)
          .neq("sender_id", context.user.id);

        unreadCount = count ?? 0;
      }

      channelPreviews.push({
        id: chId,
        tenant_id: ch.tenant_id as string,
        channel_type: ch.channel_type as ChannelType,
        name: ch.name as string | null,
        class_id: ch.class_id as string | null,
        program_id: ch.program_id as string | null,
        created_by: ch.created_by as string,
        is_active: ch.is_active as boolean,
        allow_parent_posts: ch.allow_parent_posts as boolean,
        is_moderated: ch.is_moderated as boolean,
        created_at: ch.created_at as string,
        updated_at: ch.updated_at as string,
        deleted_at: ch.deleted_at as string | null,
        member_count: Array.isArray(ch.chat_channel_members)
          ? (ch.chat_channel_members as Array<unknown>).length
          : 0,
        unread_count: unreadCount,
        last_message: lastMessage,
      });
    }

    // Sort: channels with unread messages first, then by last message time
    channelPreviews.sort((a, b) => {
      if (a.unread_count > 0 && b.unread_count === 0) return -1;
      if (a.unread_count === 0 && b.unread_count > 0) return 1;
      const aTime = a.last_message?.created_at ?? a.created_at;
      const bTime = b.last_message?.created_at ?? b.created_at;
      return new Date(bTime).getTime() - new Date(aTime).getTime();
    });

    return success(channelPreviews);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list channels";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET CHANNEL MEMBERS
// ============================================================

export interface ChannelMemberWithUser extends ChatChannelMember {
  user: Pick<User, "id" | "first_name" | "last_name" | "avatar_url">;
}

export async function getChannelMembers(
  channelId: string,
): Promise<ActionResponse<ChannelMemberWithUser[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("chat_channel_members")
      .select(
        `
        *,
        user:users!chat_channel_members_user_id_fkey(id, first_name, last_name, avatar_url)
      `,
      )
      .eq("channel_id", channelId)
      .order("joined_at", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as ChannelMemberWithUser[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get channel members";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// ADD MEMBER TO CHANNEL
// ============================================================
// Permission: MODERATE_CHAT or channel owner/admin
// ============================================================

export async function addChannelMember(
  channelId: string,
  userId: string,
  role: ChannelMemberRole = "member",
): Promise<ActionResponse<ChatChannelMember>> {
  try {
    const context = await requirePermission(Permissions.MODERATE_CHAT);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("chat_channel_members")
      .upsert(
        {
          tenant_id: context.tenant.id,
          channel_id: channelId,
          user_id: userId,
          role,
        },
        { onConflict: "tenant_id,channel_id,user_id" },
      )
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as ChatChannelMember);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to add member";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// REMOVE MEMBER FROM CHANNEL
// ============================================================

export async function removeChannelMember(
  channelId: string,
  userId: string,
): Promise<ActionResponse<{ removed: boolean }>> {
  try {
    await requirePermission(Permissions.MODERATE_CHAT);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("chat_channel_members")
      .delete()
      .eq("channel_id", channelId)
      .eq("user_id", userId);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ removed: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to remove member";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// SEND MESSAGE
// ============================================================
// Membership is enforced by RLS. The sender must be a channel
// member. The channel must be active and (if allow_parent_posts
// is false) the sender must have an admin/owner role.
// ============================================================

export async function sendMessage(
  input: SendMessageInput,
): Promise<ActionResponse<ChatMessage>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (!input.content.trim() && !input.attachment_url) {
      return failure(
        "Message content or attachment is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Verify channel exists and user is a member
    const { data: channel, error: chError } = await supabase
      .from("chat_channels")
      .select("id, is_active, allow_parent_posts")
      .eq("id", input.channel_id)
      .is("deleted_at", null)
      .single();

    if (chError || !channel) {
      return failure("Channel not found", ErrorCodes.NOT_FOUND);
    }

    const ch = channel as {
      id: string;
      is_active: boolean;
      allow_parent_posts: boolean;
    };

    if (!ch.is_active) {
      return failure(
        "This channel is no longer active",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check membership
    const { data: membership } = await supabase
      .from("chat_channel_members")
      .select("role")
      .eq("channel_id", input.channel_id)
      .eq("user_id", context.user.id)
      .limit(1);

    if (!membership || membership.length === 0) {
      return failure(
        "You are not a member of this channel",
        ErrorCodes.FORBIDDEN,
      );
    }

    const memberRole = (membership[0] as { role: string }).role;

    // If posting is restricted, check role
    if (!ch.allow_parent_posts && memberRole === "member") {
      return failure(
        "Only channel admins can post in this channel",
        ErrorCodes.FORBIDDEN,
      );
    }

    const { data, error } = await supabase
      .from("chat_messages")
      .insert({
        tenant_id: context.tenant.id,
        channel_id: input.channel_id,
        sender_id: context.user.id,
        content: input.content.trim(),
        message_type: input.message_type ?? "text",
        attachment_url: input.attachment_url ?? null,
        attachment_name: input.attachment_name ?? null,
        reply_to_id: input.reply_to_id ?? null,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    // Update the channel's updated_at to bubble it up in lists
    await supabase
      .from("chat_channels")
      .update({ updated_at: new Date().toISOString() })
      .eq("id", input.channel_id);

    return success(data as ChatMessage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to send message";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST MESSAGES (paginated, cursor-based)
// ============================================================
// Returns messages in reverse chronological order. Uses
// cursor-based pagination (before = oldest loaded message's
// created_at) for infinite scroll.
// ============================================================

export async function listMessages(
  params: ListMessagesParams,
): Promise<ActionResponse<ChatMessageWithSender[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const limit = params.limit ?? 50;

    let query = supabase
      .from("chat_messages")
      .select(
        `
        *,
        sender:users!chat_messages_sender_id_fkey(id, first_name, last_name, avatar_url)
      `,
      )
      .eq("channel_id", params.channel_id)
      .is("deleted_at", null)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (params.before) {
      query = query.lt("created_at", params.before);
    }

    const { data, error } = await query;

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Reverse so oldest is first (for chat display order)
    const messages = ((data ?? []) as ChatMessageWithSender[]).reverse();

    return success(messages);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list messages";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// MARK CHANNEL AS READ
// ============================================================
// Updates the user's last_read_at cursor. Called when the
// user opens a channel or scrolls to the bottom.
// ============================================================

export async function markChannelRead(
  channelId: string,
): Promise<ActionResponse<{ marked: boolean }>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("chat_channel_members")
      .update({ last_read_at: new Date().toISOString() })
      .eq("channel_id", channelId)
      .eq("user_id", context.user.id);

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success({ marked: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to mark as read";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// MUTE / UNMUTE CHANNEL
// ============================================================
// Toggles the muted flag on the user's membership. Muted
// channels don't send push notifications.
// ============================================================

export async function toggleChannelMute(
  channelId: string,
  muted: boolean,
): Promise<ActionResponse<{ muted: boolean }>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("chat_channel_members")
      .update({ muted })
      .eq("channel_id", channelId)
      .eq("user_id", context.user.id);

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success({ muted });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to toggle mute";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// HIDE MESSAGE (Moderation)
// ============================================================
// Permission: MODERATE_CHAT
// Hides a message from view without deleting it. Records
// who hid it and why for audit purposes.
// ============================================================

export async function hideMessage(
  messageId: string,
  reason: string,
): Promise<ActionResponse<ChatMessage>> {
  try {
    const context = await requirePermission(Permissions.MODERATE_CHAT);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("chat_messages")
      .update({
        is_hidden: true,
        hidden_by: context.user.id,
        hidden_reason: reason.trim(),
      })
      .eq("id", messageId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as ChatMessage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to hide message";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UNHIDE MESSAGE (Moderation)
// ============================================================

export async function unhideMessage(
  messageId: string,
): Promise<ActionResponse<ChatMessage>> {
  try {
    await requirePermission(Permissions.MODERATE_CHAT);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("chat_messages")
      .update({
        is_hidden: false,
        hidden_by: null,
        hidden_reason: null,
      })
      .eq("id", messageId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as ChatMessage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to unhide message";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET TOTAL UNREAD COUNT (across all channels)
// ============================================================
// Used for the global notification bell badge.
// ============================================================

export async function getTotalUnreadCount(): Promise<ActionResponse<number>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data: memberships } = await supabase
      .from("chat_channel_members")
      .select("channel_id, last_read_at")
      .eq("user_id", context.user.id);

    if (!memberships || memberships.length === 0) {
      return success(0);
    }

    let totalUnread = 0;

    for (const m of memberships as Array<{
      channel_id: string;
      last_read_at: string | null;
    }>) {
      let query = supabase
        .from("chat_messages")
        .select("id", { count: "exact", head: true })
        .eq("channel_id", m.channel_id)
        .is("deleted_at", null)
        .eq("is_hidden", false)
        .neq("sender_id", context.user.id);

      if (m.last_read_at) {
        query = query.gt("created_at", m.last_read_at);
      }

      const { count } = await query;
      totalUnread += count ?? 0;
    }

    return success(totalUnread);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get unread count";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE MESSAGE (soft delete, sender only)
// ============================================================
// Only the sender can soft-delete their own message.
// Moderators use hideMessage instead.
// ============================================================

export async function deleteMessage(
  messageId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("chat_messages")
      .update({ deleted_at: new Date().toISOString() })
      .eq("id", messageId)
      .eq("sender_id", context.user.id)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete message";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\comms\family-directory.ts =====

// src/lib/actions/comms/family-directory.ts
//
// ============================================================
// WattleOS V2 — Module 12: Family Directory & Notification Prefs
// ============================================================
// Manages the opt-in family directory where parents can connect
// with each other, and per-user notification preferences for
// controlling push/email/in-app delivery.
//
// WHY combined file: Directory entries and notification prefs
// are both per-user settings that live in the parent portal
// settings area. Grouping them reduces file sprawl.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type { User } from "@/types/domain";

// ============================================================
// Types — Family Directory
// ============================================================

export interface FamilyDirectoryEntry {
  id: string;
  tenant_id: string;
  user_id: string;
  display_name: string;
  phone_visible: boolean;
  email_visible: boolean;
  children_names: string[];
  bio: string | null;
  interests: string[];
  is_visible: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface FamilyDirectoryEntryWithUser extends FamilyDirectoryEntry {
  user: Pick<User, "id" | "email" | "first_name" | "last_name" | "avatar_url">;
}

// ============================================================
// Types — Notification Preferences
// ============================================================

export type NotificationCategory =
  | "announcements"
  | "chat_messages"
  | "observations"
  | "reports"
  | "events"
  | "attendance"
  | "billing"
  | "enrollment";

export type NotificationChannel = "push" | "email" | "in_app";

export interface NotificationPreference {
  id: string;
  tenant_id: string;
  user_id: string;
  category: NotificationCategory;
  channel: NotificationChannel;
  enabled: boolean;
  created_at: string;
  updated_at: string;
}

// ============================================================
// Input Types
// ============================================================

export interface UpsertDirectoryEntryInput {
  display_name: string;
  phone_visible?: boolean;
  email_visible?: boolean;
  children_names?: string[];
  bio?: string | null;
  interests?: string[];
  is_visible?: boolean;
}

export interface UpdateNotificationPrefInput {
  category: NotificationCategory;
  channel: NotificationChannel;
  enabled: boolean;
}

// ============================================================
// GET MY DIRECTORY ENTRY
// ============================================================
// Returns the current user's directory entry, or null if
// they haven't created one yet.
// ============================================================

export async function getMyDirectoryEntry(): Promise<
  ActionResponse<FamilyDirectoryEntry | null>
> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("family_directory_entries")
      .select("*")
      .eq("user_id", context.user.id)
      .is("deleted_at", null)
      .maybeSingle();

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success(data as FamilyDirectoryEntry | null);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get directory entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPSERT MY DIRECTORY ENTRY
// ============================================================
// Creates or updates the current user's directory listing.
// Uses upsert on (tenant_id, user_id) unique constraint.
// ============================================================

export async function upsertMyDirectoryEntry(
  input: UpsertDirectoryEntryInput,
): Promise<ActionResponse<FamilyDirectoryEntry>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (!input.display_name.trim()) {
      return failure("Display name is required", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("family_directory_entries")
      .upsert(
        {
          tenant_id: context.tenant.id,
          user_id: context.user.id,
          display_name: input.display_name.trim(),
          phone_visible: input.phone_visible ?? false,
          email_visible: input.email_visible ?? true,
          children_names: input.children_names ?? [],
          bio: input.bio?.trim() ?? null,
          interests: input.interests ?? [],
          is_visible: input.is_visible ?? true,
        },
        { onConflict: "tenant_id,user_id" },
      )
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as FamilyDirectoryEntry);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to save directory entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// REMOVE MY DIRECTORY ENTRY (soft delete)
// ============================================================
// Sets is_visible = false and soft-deletes. Effectively
// removes the user from the directory without losing data.
// ============================================================

export async function removeMyDirectoryEntry(): Promise<
  ActionResponse<{ removed: boolean }>
> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("family_directory_entries")
      .update({
        is_visible: false,
        deleted_at: new Date().toISOString(),
      })
      .eq("user_id", context.user.id)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ removed: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to remove directory entry";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// BROWSE DIRECTORY (Parent view)
// ============================================================
// Returns all visible directory entries. Only shows contact
// info fields where the user has opted in (phone_visible,
// email_visible). Respects directory consent.
// ============================================================

export async function browseDirectory(): Promise<
  ActionResponse<FamilyDirectoryEntryWithUser[]>
> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("family_directory_entries")
      .select(
        `
        *,
        user:users!family_directory_entries_user_id_fkey(id, email, first_name, last_name, avatar_url)
      `,
      )
      .eq("is_visible", true)
      .is("deleted_at", null)
      .order("display_name", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Sanitize: remove email/phone from response where not opted in
    const entries = ((data ?? []) as Array<Record<string, unknown>>).map(
      (row) => {
        const entry = row as unknown as FamilyDirectoryEntryWithUser;
        const sanitizedUser = { ...entry.user };

        // If email not visible, redact it
        if (!entry.email_visible) {
          sanitizedUser.email = "";
        }

        return {
          ...entry,
          user: sanitizedUser,
        };
      },
    );

    return success(entries);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to browse directory";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// ADMIN: GET ALL DIRECTORY ENTRIES
// ============================================================
// Permission: MANAGE_DIRECTORY
// Returns all entries including hidden ones, for admin review.
// ============================================================

export async function adminListDirectoryEntries(): Promise<
  ActionResponse<FamilyDirectoryEntryWithUser[]>
> {
  try {
    await requirePermission(Permissions.MANAGE_DIRECTORY);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("family_directory_entries")
      .select(
        `
        *,
        user:users!family_directory_entries_user_id_fkey(id, email, first_name, last_name, avatar_url)
      `,
      )
      .is("deleted_at", null)
      .order("display_name", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as FamilyDirectoryEntryWithUser[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list directory entries";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// NOTIFICATION PREFERENCES
// ============================================================

// ============================================================
// GET MY NOTIFICATION PREFERENCES
// ============================================================
// Returns all notification preferences for the current user.
// If no preferences exist yet, returns an empty array (the UI
// should display defaults as enabled).
// ============================================================

export async function getMyNotificationPreferences(): Promise<
  ActionResponse<NotificationPreference[]>
> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("notification_preferences")
      .select("*")
      .eq("user_id", context.user.id)
      .order("category", { ascending: true })
      .order("channel", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as NotificationPreference[]);
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Failed to get notification preferences";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE NOTIFICATION PREFERENCE
// ============================================================
// Upserts a single category/channel preference. The UI
// typically shows a grid of toggles (category × channel).
// ============================================================

export async function updateNotificationPreference(
  input: UpdateNotificationPrefInput,
): Promise<ActionResponse<NotificationPreference>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("notification_preferences")
      .upsert(
        {
          tenant_id: context.tenant.id,
          user_id: context.user.id,
          category: input.category,
          channel: input.channel,
          enabled: input.enabled,
        },
        { onConflict: "tenant_id,user_id,category,channel" },
      )
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success(data as NotificationPreference);
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Failed to update notification preference";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// BULK UPDATE NOTIFICATION PREFERENCES
// ============================================================
// Updates multiple preferences at once. Used when the parent
// toggles "mute all" or saves the full preferences grid.
// ============================================================

export async function bulkUpdateNotificationPreferences(
  preferences: UpdateNotificationPrefInput[],
): Promise<ActionResponse<NotificationPreference[]>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (preferences.length === 0) {
      return failure("No preferences to update", ErrorCodes.VALIDATION_ERROR);
    }

    const rows = preferences.map((pref) => ({
      tenant_id: context.tenant.id,
      user_id: context.user.id,
      category: pref.category,
      channel: pref.channel,
      enabled: pref.enabled,
    }));

    const { data, error } = await supabase
      .from("notification_preferences")
      .upsert(rows, { onConflict: "tenant_id,user_id,category,channel" })
      .select();

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as NotificationPreference[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update preferences";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CHECK IF USER HAS NOTIFICATION ENABLED (internal helper)
// ============================================================
// Used by other modules (e.g., observation publishing,
// attendance marking) to check if a user wants notifications
// for a given category and channel before sending.
//
// Returns true if no preference exists (default = enabled).
// ============================================================

export async function isNotificationEnabled(
  userId: string,
  category: NotificationCategory,
  channel: NotificationChannel,
): Promise<boolean> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data } = await supabase
      .from("notification_preferences")
      .select("enabled")
      .eq("user_id", userId)
      .eq("category", category)
      .eq("channel", channel)
      .maybeSingle();

    // Default to enabled if no preference exists
    if (!data) return true;

    return (data as { enabled: boolean }).enabled;
  } catch {
    // Fail open: if we can't check preferences, allow the notification
    return true;
  }
}


===== D:\.code\wattleos\src\lib\actions\comms\school-events.ts =====

// src/lib/actions/comms/school-events.ts
//
// ============================================================
// WattleOS V2 — Module 12: School Event Server Actions
// ============================================================
// Full event lifecycle: create → publish → RSVP → track.
// Events can be school-wide, class-specific, program-specific,
// or staff-only. Supports RSVP with guest counts and capacity
// limits.
//
// WHY events in comms not a separate module: Events are a
// communication channel. They appear in the parent news feed
// alongside announcements and chat updates. Keeping them in
// comms ensures a unified communication experience.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  ActionResponse,
  ErrorCodes,
  failure,
  paginated,
  paginatedFailure,
  PaginatedResponse,
  success,
} from "@/types/api";
import type { Class, User } from "@/types/domain";

// ============================================================
// Types
// ============================================================

export type EventType =
  | "general"
  | "excursion"
  | "parent_meeting"
  | "performance"
  | "sports_day"
  | "fundraiser"
  | "professional_development"
  | "public_holiday"
  | "pupil_free_day"
  | "term_start"
  | "term_end";

export type EventScope = "school" | "class" | "program" | "staff";
export type RSVPStatus = "going" | "not_going" | "maybe";

export interface EventAttachment {
  name: string;
  url: string;
}

export interface SchoolEvent {
  id: string;
  tenant_id: string;
  title: string;
  description: string | null;
  event_type: EventType;
  start_at: string;
  end_at: string | null;
  all_day: boolean;
  location: string | null;
  location_url: string | null;
  scope: EventScope;
  target_class_id: string | null;
  target_program_id: string | null;
  rsvp_enabled: boolean;
  rsvp_deadline: string | null;
  max_attendees: number | null;
  created_by: string;
  attachment_urls: EventAttachment[];
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface SchoolEventWithDetails extends SchoolEvent {
  creator: Pick<User, "id" | "first_name" | "last_name">;
  target_class: Pick<Class, "id" | "name"> | null;
  rsvp_summary: {
    going: number;
    not_going: number;
    maybe: number;
    total_guests: number;
  };
  my_rsvp: EventRSVP | null;
}

export interface EventRSVP {
  id: string;
  tenant_id: string;
  event_id: string;
  user_id: string;
  status: RSVPStatus;
  guests: number;
  notes: string | null;
  responded_at: string;
}

export interface EventRSVPWithUser extends EventRSVP {
  user: Pick<User, "id" | "first_name" | "last_name" | "avatar_url">;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateEventInput {
  title: string;
  description?: string | null;
  event_type: EventType;
  start_at: string;
  end_at?: string | null;
  all_day?: boolean;
  location?: string | null;
  location_url?: string | null;
  scope: EventScope;
  target_class_id?: string | null;
  target_program_id?: string | null;
  rsvp_enabled?: boolean;
  rsvp_deadline?: string | null;
  max_attendees?: number | null;
  attachment_urls?: EventAttachment[];
}

export interface UpdateEventInput {
  title?: string;
  description?: string | null;
  event_type?: EventType;
  start_at?: string;
  end_at?: string | null;
  all_day?: boolean;
  location?: string | null;
  location_url?: string | null;
  scope?: EventScope;
  target_class_id?: string | null;
  target_program_id?: string | null;
  rsvp_enabled?: boolean;
  rsvp_deadline?: string | null;
  max_attendees?: number | null;
  attachment_urls?: EventAttachment[];
}

export interface ListEventsParams {
  scope?: EventScope;
  event_type?: EventType;
  target_class_id?: string;
  from_date?: string;
  to_date?: string;
  page?: number;
  per_page?: number;
}

// ============================================================
// CREATE EVENT
// ============================================================
// Permission: MANAGE_EVENTS
// ============================================================

export async function createEvent(
  input: CreateEventInput,
): Promise<ActionResponse<SchoolEvent>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_EVENTS);
    const supabase = await createSupabaseServerClient();

    if (!input.title.trim()) {
      return failure("Event title is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.start_at) {
      return failure(
        "Start date/time is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (input.scope === "class" && !input.target_class_id) {
      return failure(
        "A target class is required for class-scoped events",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (input.scope === "program" && !input.target_program_id) {
      return failure(
        "A target program is required for program-scoped events",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (input.end_at && new Date(input.end_at) < new Date(input.start_at)) {
      return failure(
        "End time cannot be before start time",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("school_events")
      .insert({
        tenant_id: context.tenant.id,
        title: input.title.trim(),
        description: input.description?.trim() ?? null,
        event_type: input.event_type,
        start_at: input.start_at,
        end_at: input.end_at ?? null,
        all_day: input.all_day ?? false,
        location: input.location?.trim() ?? null,
        location_url: input.location_url?.trim() ?? null,
        scope: input.scope,
        target_class_id: input.scope === "class" ? input.target_class_id : null,
        target_program_id:
          input.scope === "program" ? input.target_program_id : null,
        rsvp_enabled: input.rsvp_enabled ?? false,
        rsvp_deadline: input.rsvp_deadline ?? null,
        max_attendees: input.max_attendees ?? null,
        created_by: context.user.id,
        attachment_urls: JSON.stringify(input.attachment_urls ?? []),
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as SchoolEvent);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create event";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE EVENT
// ============================================================

export async function updateEvent(
  eventId: string,
  input: UpdateEventInput,
): Promise<ActionResponse<SchoolEvent>> {
  try {
    await requirePermission(Permissions.MANAGE_EVENTS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.title !== undefined) updateData.title = input.title.trim();
    if (input.description !== undefined)
      updateData.description = input.description?.trim() ?? null;
    if (input.event_type !== undefined)
      updateData.event_type = input.event_type;
    if (input.start_at !== undefined) updateData.start_at = input.start_at;
    if (input.end_at !== undefined) updateData.end_at = input.end_at;
    if (input.all_day !== undefined) updateData.all_day = input.all_day;
    if (input.location !== undefined)
      updateData.location = input.location?.trim() ?? null;
    if (input.location_url !== undefined)
      updateData.location_url = input.location_url?.trim() ?? null;
    if (input.scope !== undefined) updateData.scope = input.scope;
    if (input.target_class_id !== undefined)
      updateData.target_class_id = input.target_class_id;
    if (input.target_program_id !== undefined)
      updateData.target_program_id = input.target_program_id;
    if (input.rsvp_enabled !== undefined)
      updateData.rsvp_enabled = input.rsvp_enabled;
    if (input.rsvp_deadline !== undefined)
      updateData.rsvp_deadline = input.rsvp_deadline;
    if (input.max_attendees !== undefined)
      updateData.max_attendees = input.max_attendees;
    if (input.attachment_urls !== undefined)
      updateData.attachment_urls = JSON.stringify(input.attachment_urls);

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("school_events")
      .update(updateData)
      .eq("id", eventId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as SchoolEvent);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update event";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE EVENT (soft delete)
// ============================================================

export async function deleteEvent(
  eventId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(Permissions.MANAGE_EVENTS);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("school_events")
      .update({ deleted_at: new Date().toISOString() })
      .eq("id", eventId)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete event";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST EVENTS (Staff view — paginated calendar)
// ============================================================
// Permission: MANAGE_EVENTS
// Returns events in chronological order with RSVP summaries.
// ============================================================

export async function listEvents(
  params: ListEventsParams = {},
): Promise<PaginatedResponse<SchoolEventWithDetails>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_EVENTS);
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 25;
    const offset = (page - 1) * perPage;

    // Count
    let countQuery = supabase
      .from("school_events")
      .select("id", { count: "exact", head: true })
      .is("deleted_at", null);

    if (params.scope) countQuery = countQuery.eq("scope", params.scope);
    if (params.event_type)
      countQuery = countQuery.eq("event_type", params.event_type);
    if (params.target_class_id)
      countQuery = countQuery.eq("target_class_id", params.target_class_id);
    if (params.from_date)
      countQuery = countQuery.gte("start_at", params.from_date);
    if (params.to_date) countQuery = countQuery.lte("start_at", params.to_date);

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    let query = supabase
      .from("school_events")
      .select(
        `
        *,
        creator:users!school_events_created_by_fkey(id, first_name, last_name),
        target_class:classes!school_events_target_class_id_fkey(id, name),
        event_rsvps(id, status, guests)
      `,
      )
      .is("deleted_at", null)
      .order("start_at", { ascending: true })
      .range(offset, offset + perPage - 1);

    if (params.scope) query = query.eq("scope", params.scope);
    if (params.event_type) query = query.eq("event_type", params.event_type);
    if (params.target_class_id)
      query = query.eq("target_class_id", params.target_class_id);
    if (params.from_date) query = query.gte("start_at", params.from_date);
    if (params.to_date) query = query.lte("start_at", params.to_date);

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Get current user's RSVPs
    const eventIds = ((data ?? []) as Array<{ id: string }>).map((e) => e.id);
    let myRsvpMap = new Map<string, EventRSVP>();

    if (eventIds.length > 0) {
      const { data: myRsvps } = await supabase
        .from("event_rsvps")
        .select("*")
        .eq("user_id", context.user.id)
        .in("event_id", eventIds);

      for (const r of (myRsvps ?? []) as EventRSVP[]) {
        myRsvpMap.set(r.event_id, r);
      }
    }

    const events: SchoolEventWithDetails[] = (
      (data ?? []) as Array<Record<string, unknown>>
    ).map((row) => {
      const rsvps = (row.event_rsvps ?? []) as Array<{
        id: string;
        status: RSVPStatus;
        guests: number;
      }>;
      const goingCount = rsvps.filter((r) => r.status === "going").length;
      const notGoingCount = rsvps.filter(
        (r) => r.status === "not_going",
      ).length;
      const maybeCount = rsvps.filter((r) => r.status === "maybe").length;
      const totalGuests = rsvps.reduce((sum, r) => sum + r.guests, 0);

      return {
        id: row.id as string,
        tenant_id: row.tenant_id as string,
        title: row.title as string,
        description: row.description as string | null,
        event_type: row.event_type as EventType,
        start_at: row.start_at as string,
        end_at: row.end_at as string | null,
        all_day: row.all_day as boolean,
        location: row.location as string | null,
        location_url: row.location_url as string | null,
        scope: row.scope as EventScope,
        target_class_id: row.target_class_id as string | null,
        target_program_id: row.target_program_id as string | null,
        rsvp_enabled: row.rsvp_enabled as boolean,
        rsvp_deadline: row.rsvp_deadline as string | null,
        max_attendees: row.max_attendees as number | null,
        created_by: row.created_by as string,
        attachment_urls: (row.attachment_urls ?? []) as EventAttachment[],
        created_at: row.created_at as string,
        updated_at: row.updated_at as string,
        deleted_at: row.deleted_at as string | null,
        creator: row.creator as Pick<User, "id" | "first_name" | "last_name">,
        target_class: row.target_class as Pick<Class, "id" | "name"> | null,
        rsvp_summary: {
          going: goingCount,
          not_going: notGoingCount,
          maybe: maybeCount,
          total_guests: totalGuests,
        },
        my_rsvp: myRsvpMap.get(row.id as string) ?? null,
      };
    });

    return paginated(events, total, page, perPage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list events";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET EVENTS FOR PARENT
// ============================================================
// Returns upcoming events visible to the parent based on
// their children's class enrollments. No special permission.
// ============================================================

export async function getEventsForParent(
  params: {
    from_date?: string;
    to_date?: string;
    page?: number;
    per_page?: number;
  } = {},
): Promise<PaginatedResponse<SchoolEventWithDetails>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 25;
    const offset = (page - 1) * perPage;

    // Resolve parent's class IDs
    const { data: guardianships } = await supabase
      .from("guardians")
      .select("student_id")
      .eq("user_id", context.user.id)
      .is("deleted_at", null);

    const studentIds = (guardianships ?? []).map(
      (g) => (g as { student_id: string }).student_id,
    );

    let classIds: string[] = [];
    if (studentIds.length > 0) {
      const { data: enrollments } = await supabase
        .from("enrollments")
        .select("class_id")
        .in("student_id", studentIds)
        .eq("status", "active")
        .is("deleted_at", null);

      classIds = [
        ...new Set(
          (enrollments ?? []).map((e) => (e as { class_id: string }).class_id),
        ),
      ];
    }

    // Scope filter: school-wide OR class events for parent's classes
    // Exclude staff-only events
    let scopeFilter: string;
    if (classIds.length > 0) {
      scopeFilter = `scope.eq.school,and(scope.eq.class,target_class_id.in.(${classIds.join(",")}))`;
    } else {
      scopeFilter = "scope.eq.school";
    }

    // Default to showing upcoming events from now
    const fromDate = params.from_date ?? new Date().toISOString();

    // Count
    let countQuery = supabase
      .from("school_events")
      .select("id", { count: "exact", head: true })
      .is("deleted_at", null)
      .neq("scope", "staff")
      .gte("start_at", fromDate)
      .or(scopeFilter);

    if (params.to_date) {
      countQuery = countQuery.lte("start_at", params.to_date);
    }

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    let query = supabase
      .from("school_events")
      .select(
        `
        *,
        creator:users!school_events_created_by_fkey(id, first_name, last_name),
        target_class:classes!school_events_target_class_id_fkey(id, name),
        event_rsvps(id, status, guests)
      `,
      )
      .is("deleted_at", null)
      .neq("scope", "staff")
      .gte("start_at", fromDate)
      .or(scopeFilter)
      .order("start_at", { ascending: true })
      .range(offset, offset + perPage - 1);

    if (params.to_date) {
      query = query.lte("start_at", params.to_date);
    }

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // My RSVPs
    const eventIds = ((data ?? []) as Array<{ id: string }>).map((e) => e.id);
    let myRsvpMap = new Map<string, EventRSVP>();

    if (eventIds.length > 0) {
      const { data: myRsvps } = await supabase
        .from("event_rsvps")
        .select("*")
        .eq("user_id", context.user.id)
        .in("event_id", eventIds);

      for (const r of (myRsvps ?? []) as EventRSVP[]) {
        myRsvpMap.set(r.event_id, r);
      }
    }

    const events: SchoolEventWithDetails[] = (
      (data ?? []) as Array<Record<string, unknown>>
    ).map((row) => {
      const rsvps = (row.event_rsvps ?? []) as Array<{
        id: string;
        status: RSVPStatus;
        guests: number;
      }>;

      return {
        id: row.id as string,
        tenant_id: row.tenant_id as string,
        title: row.title as string,
        description: row.description as string | null,
        event_type: row.event_type as EventType,
        start_at: row.start_at as string,
        end_at: row.end_at as string | null,
        all_day: row.all_day as boolean,
        location: row.location as string | null,
        location_url: row.location_url as string | null,
        scope: row.scope as EventScope,
        target_class_id: row.target_class_id as string | null,
        target_program_id: row.target_program_id as string | null,
        rsvp_enabled: row.rsvp_enabled as boolean,
        rsvp_deadline: row.rsvp_deadline as string | null,
        max_attendees: row.max_attendees as number | null,
        created_by: row.created_by as string,
        attachment_urls: (row.attachment_urls ?? []) as EventAttachment[],
        created_at: row.created_at as string,
        updated_at: row.updated_at as string,
        deleted_at: row.deleted_at as string | null,
        creator: row.creator as Pick<User, "id" | "first_name" | "last_name">,
        target_class: row.target_class as Pick<Class, "id" | "name"> | null,
        rsvp_summary: {
          going: rsvps.filter((r) => r.status === "going").length,
          not_going: rsvps.filter((r) => r.status === "not_going").length,
          maybe: rsvps.filter((r) => r.status === "maybe").length,
          total_guests: rsvps.reduce((sum, r) => sum + r.guests, 0),
        },
        my_rsvp: myRsvpMap.get(row.id as string) ?? null,
      };
    });

    return paginated(events, total, page, perPage);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to get events";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SINGLE EVENT
// ============================================================

export async function getEvent(
  eventId: string,
): Promise<ActionResponse<SchoolEventWithDetails>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("school_events")
      .select(
        `
        *,
        creator:users!school_events_created_by_fkey(id, first_name, last_name),
        target_class:classes!school_events_target_class_id_fkey(id, name),
        event_rsvps(id, status, guests)
      `,
      )
      .eq("id", eventId)
      .is("deleted_at", null)
      .single();

    if (error) {
      return failure("Event not found", ErrorCodes.NOT_FOUND);
    }

    const row = data as Record<string, unknown>;
    const rsvps = (row.event_rsvps ?? []) as Array<{
      id: string;
      status: RSVPStatus;
      guests: number;
    }>;

    // Current user's RSVP
    const { data: myRsvps } = await supabase
      .from("event_rsvps")
      .select("*")
      .eq("event_id", eventId)
      .eq("user_id", context.user.id)
      .limit(1);

    const event: SchoolEventWithDetails = {
      id: row.id as string,
      tenant_id: row.tenant_id as string,
      title: row.title as string,
      description: row.description as string | null,
      event_type: row.event_type as EventType,
      start_at: row.start_at as string,
      end_at: row.end_at as string | null,
      all_day: row.all_day as boolean,
      location: row.location as string | null,
      location_url: row.location_url as string | null,
      scope: row.scope as EventScope,
      target_class_id: row.target_class_id as string | null,
      target_program_id: row.target_program_id as string | null,
      rsvp_enabled: row.rsvp_enabled as boolean,
      rsvp_deadline: row.rsvp_deadline as string | null,
      max_attendees: row.max_attendees as number | null,
      created_by: row.created_by as string,
      attachment_urls: (row.attachment_urls ?? []) as EventAttachment[],
      created_at: row.created_at as string,
      updated_at: row.updated_at as string,
      deleted_at: row.deleted_at as string | null,
      creator: row.creator as Pick<User, "id" | "first_name" | "last_name">,
      target_class: row.target_class as Pick<Class, "id" | "name"> | null,
      rsvp_summary: {
        going: rsvps.filter((r) => r.status === "going").length,
        not_going: rsvps.filter((r) => r.status === "not_going").length,
        maybe: rsvps.filter((r) => r.status === "maybe").length,
        total_guests: rsvps.reduce((sum, r) => sum + r.guests, 0),
      },
      my_rsvp: myRsvps && myRsvps.length > 0 ? (myRsvps[0] as EventRSVP) : null,
    };

    return success(event);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to get event";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// RESPOND TO EVENT (RSVP)
// ============================================================
// Upserts on (tenant_id, event_id, user_id). Any authenticated
// tenant member can RSVP. Checks capacity limits and deadlines.
// ============================================================

export async function respondToEvent(
  eventId: string,
  rsvpStatus: RSVPStatus,
  guests: number = 0,
  notes?: string | null,
): Promise<ActionResponse<EventRSVP>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Fetch event to check constraints
    const { data: event, error: eventError } = await supabase
      .from("school_events")
      .select("id, rsvp_enabled, rsvp_deadline, max_attendees")
      .eq("id", eventId)
      .is("deleted_at", null)
      .single();

    if (eventError || !event) {
      return failure("Event not found", ErrorCodes.NOT_FOUND);
    }

    const evt = event as {
      id: string;
      rsvp_enabled: boolean;
      rsvp_deadline: string | null;
      max_attendees: number | null;
    };

    if (!evt.rsvp_enabled) {
      return failure(
        "RSVP is not enabled for this event",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check deadline
    if (evt.rsvp_deadline && new Date(evt.rsvp_deadline) < new Date()) {
      return failure("RSVP deadline has passed", ErrorCodes.VALIDATION_ERROR);
    }

    // Check capacity (only for 'going' responses)
    if (rsvpStatus === "going" && evt.max_attendees !== null) {
      const { count: currentGoing } = await supabase
        .from("event_rsvps")
        .select("id", { count: "exact", head: true })
        .eq("event_id", eventId)
        .eq("status", "going")
        .neq("user_id", context.user.id); // Exclude current user (they may be updating)

      const { data: currentGuests } = await supabase
        .from("event_rsvps")
        .select("guests")
        .eq("event_id", eventId)
        .eq("status", "going")
        .neq("user_id", context.user.id);

      const totalAttending =
        (currentGoing ?? 0) +
        (currentGuests ?? []).reduce(
          (sum, r) => sum + ((r as { guests: number }).guests ?? 0),
          0,
        );

      if (totalAttending + 1 + guests > evt.max_attendees) {
        return failure(
          `This event has reached its maximum capacity of ${evt.max_attendees}`,
          ErrorCodes.VALIDATION_ERROR,
        );
      }
    }

    if (guests < 0) {
      return failure(
        "Guest count cannot be negative",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("event_rsvps")
      .upsert(
        {
          tenant_id: context.tenant.id,
          event_id: eventId,
          user_id: context.user.id,
          status: rsvpStatus,
          guests,
          notes: notes?.trim() ?? null,
          responded_at: new Date().toISOString(),
        },
        { onConflict: "tenant_id,event_id,user_id" },
      )
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success(data as EventRSVP);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to RSVP";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET EVENT RSVP LIST (Staff view)
// ============================================================
// Returns all RSVPs with user details, grouped by status.
// Permission: MANAGE_EVENTS
// ============================================================

export async function getEventRSVPs(
  eventId: string,
): Promise<ActionResponse<EventRSVPWithUser[]>> {
  try {
    await requirePermission(Permissions.MANAGE_EVENTS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("event_rsvps")
      .select(
        `
        *,
        user:users!event_rsvps_user_id_fkey(id, first_name, last_name, avatar_url)
      `,
      )
      .eq("event_id", eventId)
      .order("responded_at", { ascending: false });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as EventRSVPWithUser[]);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to get RSVPs";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\curriculum-content\content-library.ts =====

"use server";

// ============================================================
// WattleOS V2 — Module 14: Curriculum Content Library
// ============================================================
// Enhanced queries for the curriculum content library. Extends
// Module 2's basic CRUD with framework-aware filtering, material
// search, compliance reporting, and JSON template import.
//
// WHY this file is separate from curriculum.ts: Module 2 handles
// the core engine (instances, nodes, forking). Module 14 adds
// the content layer — richer metadata, cross-framework queries,
// and compliance reporting that didn't exist in the original
// curriculum engine design.
// ============================================================

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import {
  createSupabaseAdminClient,
  createSupabaseServerClient,
} from "@/lib/supabase/server";
import type { ActionResponse } from "@/types/api";
import { ErrorCodes, failure, success } from "@/types/api";
import type { CurriculumNode, CurriculumTemplate } from "@/types/domain";

// ============================================================
// Types
// ============================================================

/** Extended template with the new Module 14 columns */
export interface EnhancedCurriculumTemplate extends CurriculumTemplate {
  framework: string | null;
  age_range: string | null;
  country: string | null;
  state: string | null;
  version: string | null;
  is_compliance_framework: boolean;
}

/** Extended node with the new Module 14 columns */
export interface EnhancedCurriculumNode extends CurriculumNode {
  code: string | null;
  materials: string[] | null;
  direct_aims: string[] | null;
  indirect_aims: string[] | null;
  age_range: string | null;
  prerequisites: string[] | null;
  assessment_criteria: string | null;
  content_url: string | null;
}

/** Filter options for template listing */
export interface TemplateFilter {
  framework?: string;
  age_range?: string;
  country?: string;
  state?: string;
  is_compliance_framework?: boolean;
  search?: string;
}

/** Material search result — a node with its template context */
export interface MaterialSearchResult {
  node_id: string;
  node_title: string;
  node_code: string | null;
  node_level: string;
  materials: string[];
  template_id: string;
  template_name: string;
  framework: string | null;
  instance_id: string | null;
  instance_name: string | null;
}

/** Compliance evidence item — an observation or mastery record tagged with a compliance outcome */
export interface ComplianceEvidence {
  type: "observation" | "mastery";
  id: string;
  /** For observations: content snippet. For mastery: status. */
  summary: string;
  student_name: string;
  student_id: string;
  date: string;
  /** The AMI (or other pedagogical) outcome that was directly tagged */
  source_outcome: {
    id: string;
    title: string;
    code: string | null;
  } | null;
}

/** Compliance report for a single compliance framework outcome */
export interface ComplianceReportItem {
  outcome_id: string;
  outcome_title: string;
  outcome_code: string | null;
  evidence_count: number;
  evidence: ComplianceEvidence[];
}

/** Full compliance report for a framework */
export interface ComplianceReport {
  framework: string;
  template_id: string;
  template_name: string;
  generated_at: string;
  outcomes: ComplianceReportItem[];
  total_evidence: number;
  outcomes_with_evidence: number;
  outcomes_without_evidence: number;
}

/** JSON template import format — matches the spec in MODULES_10_14_DESIGN.md */
export interface JsonTemplateNode {
  level: string;
  title: string;
  code?: string;
  description?: string;
  materials?: string[];
  direct_aims?: string[];
  indirect_aims?: string[];
  age_range?: string;
  assessment_criteria?: string;
  content_url?: string;
  cross_mappings?: Array<{
    framework: string;
    code: string;
    type: string;
  }>;
  children?: JsonTemplateNode[];
}

export interface JsonTemplateImport {
  slug: string;
  name: string;
  framework: string;
  age_range: string;
  country?: string;
  state?: string;
  version: string;
  is_compliance_framework?: boolean;
  nodes: JsonTemplateNode[];
}

// ============================================================
// Permission keys
// ============================================================

const PERM_VIEW_COMPLIANCE = "view_compliance_reports";
const PERM_MANAGE_TEMPLATES = "manage_curriculum_templates";

// ============================================================
// LIST: Get templates with Module 14 enhanced filtering
// ============================================================
// WHY: The original listCurriculumTemplates() returns all active
// templates with no filtering. With 20+ templates across AMI,
// AMS, EYLF, ACARA, QCAA, schools need to filter by what's
// relevant to their age range and compliance needs.
// ============================================================

export async function listTemplatesFiltered(
  filter: TemplateFilter = {},
): Promise<ActionResponse<EnhancedCurriculumTemplate[]>> {
  try {
    // Templates are global — any authenticated user can read them
    await getTenantContext();
    const adminClient = createSupabaseAdminClient();

    let query = adminClient
      .from("curriculum_templates")
      .select("*")
      .eq("is_active", true);

    if (filter.framework) {
      query = query.eq("framework", filter.framework);
    }
    if (filter.age_range) {
      query = query.eq("age_range", filter.age_range);
    }
    if (filter.country) {
      query = query.eq("country", filter.country);
    }
    if (filter.state) {
      query = query.eq("state", filter.state);
    }
    if (filter.is_compliance_framework !== undefined) {
      query = query.eq(
        "is_compliance_framework",
        filter.is_compliance_framework,
      );
    }
    if (filter.search) {
      query = query.ilike("name", `%${filter.search}%`);
    }

    const { data, error } = await query.order("framework").order("name");

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    return success((data ?? []) as EnhancedCurriculumTemplate[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list templates";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// LIST: Get distinct frameworks available in templates
// ============================================================
// WHY: Populates the framework filter dropdown in the UI
// without hardcoding framework names.
// ============================================================

export async function listAvailableFrameworks(): Promise<
  ActionResponse<string[]>
> {
  try {
    await getTenantContext();
    const adminClient = createSupabaseAdminClient();

    const { data, error } = await adminClient
      .from("curriculum_templates")
      .select("framework")
      .eq("is_active", true)
      .not("framework", "is", null);

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    const frameworks = [
      ...new Set(
        ((data ?? []) as Array<{ framework: string | null }>)
          .map((r) => r.framework)
          .filter((f): f is string => f !== null),
      ),
    ].sort();

    return success(frameworks);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list frameworks";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// LIST: Get distinct age ranges available in templates
// ============================================================

export async function listAvailableAgeRanges(): Promise<
  ActionResponse<string[]>
> {
  try {
    await getTenantContext();
    const adminClient = createSupabaseAdminClient();

    const { data, error } = await adminClient
      .from("curriculum_templates")
      .select("age_range")
      .eq("is_active", true)
      .not("age_range", "is", null);

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    const ageRanges = [
      ...new Set(
        ((data ?? []) as Array<{ age_range: string | null }>)
          .map((r) => r.age_range)
          .filter((a): a is string => a !== null),
      ),
    ];

    // Sort age ranges sensibly: 0-3, 3-6, 6-9, etc.
    ageRanges.sort((a, b) => {
      const aStart = parseFloat(a.split("-")[0] ?? "0");
      const bStart = parseFloat(b.split("-")[0] ?? "0");
      return aStart - bStart;
    });

    return success(ageRanges);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list age ranges";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// SEARCH: Find curriculum nodes by material name
// ============================================================
// WHY: "Which outcomes use the Pink Tower?" is a common query
// from Montessori guides when planning lessons. The materials
// array on curriculum_nodes makes this searchable.
// ============================================================

export async function searchNodesByMaterial(
  materialQuery: string,
  options?: {
    instance_id?: string;
    template_id?: string;
    limit?: number;
  },
): Promise<ActionResponse<MaterialSearchResult[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();
    const adminClient = createSupabaseAdminClient();

    const limit = options?.limit ?? 50;
    const results: MaterialSearchResult[] = [];

    // Search tenant's curriculum instances (nodes they've forked)
    if (options?.instance_id || !options?.template_id) {
      let instanceQuery = supabase
        .from("curriculum_nodes")
        .select(
          `
          id, title, code, level, materials, instance_id,
          instance:curriculum_instances!curriculum_nodes_instance_id_fkey(id, name, source_template_id)
        `,
        )
        .is("deleted_at", null)
        .not("materials", "is", null)
        .contains("materials", [materialQuery])
        .limit(limit);

      if (options?.instance_id) {
        instanceQuery = instanceQuery.eq("instance_id", options.instance_id);
      }

      const { data: instanceNodes, error: instanceError } = await instanceQuery;

      if (instanceError) {
        return failure(instanceError.message, ErrorCodes.INTERNAL_ERROR);
      }

      for (const row of instanceNodes ?? []) {
        const r = row as Record<string, unknown>;
        const instance = unwrapJoin(r.instance);

        results.push({
          node_id: r.id as string,
          node_title: r.title as string,
          node_code: (r.code as string) ?? null,
          node_level: r.level as string,
          materials: (r.materials as string[]) ?? [],
          template_id: (instance?.source_template_id as string) ?? "",
          template_name: "",
          framework: null,
          instance_id: (instance?.id as string) ?? null,
          instance_name: (instance?.name as string) ?? null,
        });
      }
    }

    // Also search global template nodes if no specific instance
    if (options?.template_id || !options?.instance_id) {
      let templateQuery = adminClient
        .from("curriculum_template_nodes")
        .select(
          `
          id, title, code, level, materials, template_id,
          template:curriculum_templates!curriculum_template_nodes_template_id_fkey(id, name, framework)
        `,
        )
        .not("materials", "is", null)
        .contains("materials", [materialQuery])
        .limit(limit);

      if (options?.template_id) {
        templateQuery = templateQuery.eq("template_id", options.template_id);
      }

      const { data: templateNodes, error: templateError } = await templateQuery;

      // Template nodes table may not exist yet or may not have materials column.
      // Fall back gracefully — this is a search, not critical path.
      if (!templateError && templateNodes) {
        for (const row of templateNodes) {
          const r = row as Record<string, unknown>;
          const template = unwrapJoin(r.template);

          results.push({
            node_id: r.id as string,
            node_title: r.title as string,
            node_code: (r.code as string) ?? null,
            node_level: r.level as string,
            materials: (r.materials as string[]) ?? [],
            template_id: (template?.id as string) ?? "",
            template_name: (template?.name as string) ?? "",
            framework: (template?.framework as string) ?? null,
            instance_id: null,
            instance_name: null,
          });
        }
      }
    }

    return success(results.slice(0, limit));
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to search by material";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// SEARCH: Find nodes by official code
// ============================================================
// WHY: Teachers and compliance officers reference outcomes by
// code (e.g., "ACMNA001", "EYLF-3.2"). Quick lookup by code.
// ============================================================

export async function searchNodesByCode(
  code: string,
  options?: {
    instance_id?: string;
    exact?: boolean;
    limit?: number;
  },
): Promise<ActionResponse<EnhancedCurriculumNode[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const limit = options?.limit ?? 20;

    let query = supabase
      .from("curriculum_nodes")
      .select("*")
      .is("deleted_at", null)
      .not("code", "is", null);

    if (options?.instance_id) {
      query = query.eq("instance_id", options.instance_id);
    }

    if (options?.exact) {
      query = query.eq("code", code);
    } else {
      query = query.ilike("code", `%${code}%`);
    }

    const { data, error } = await query.order("code").limit(limit);

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    return success((data ?? []) as EnhancedCurriculumNode[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to search by code";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// REPORT: Generate compliance report for a framework
// ============================================================
// WHY: During ACECQA assessment & rating visits, the school
// must demonstrate evidence against every EYLF outcome. This
// function generates: "For each EYLF outcome, here are all
// observations and mastery records that map to it (via cross-
// mappings from AMI outcomes)."
//
// The report traverses: compliance outcome ← cross-mapping →
// pedagogical outcome → observation_outcomes / student_mastery
// ============================================================

export async function generateComplianceReport(
  complianceTemplateId: string,
  options?: {
    /** Only include evidence from this date onwards */
    from_date?: string;
    /** Only include evidence up to this date */
    to_date?: string;
    /** Only include evidence for this student */
    student_id?: string;
    /** Only include evidence for this class */
    class_id?: string;
  },
): Promise<ActionResponse<ComplianceReport>> {
  try {
    await requirePermission(PERM_VIEW_COMPLIANCE);
    const supabase = await createSupabaseServerClient();
    const adminClient = createSupabaseAdminClient();

    // 1. Fetch the compliance template
    const { data: template, error: templateError } = await adminClient
      .from("curriculum_templates")
      .select("*")
      .eq("id", complianceTemplateId)
      .single();

    if (templateError || !template) {
      return failure("Compliance template not found", ErrorCodes.NOT_FOUND);
    }

    const typedTemplate = template as Record<string, unknown>;
    const framework = (typedTemplate.framework as string) ?? "Unknown";
    const templateName = typedTemplate.name as string;

    // 2. Fetch all outcome-level nodes in this compliance template
    const { data: complianceNodes, error: nodesError } = await adminClient
      .from("curriculum_template_nodes")
      .select("id, title, code, level")
      .eq("template_id", complianceTemplateId)
      .in("level", ["outcome", "strand"])
      .order("sequence_order");

    if (nodesError) {
      return failure(nodesError.message, ErrorCodes.INTERNAL_ERROR);
    }

    if (!complianceNodes || complianceNodes.length === 0) {
      return success({
        framework,
        template_id: complianceTemplateId,
        template_name: templateName,
        generated_at: new Date().toISOString(),
        outcomes: [],
        total_evidence: 0,
        outcomes_with_evidence: 0,
        outcomes_without_evidence: 0,
      });
    }

    // 3. For each compliance node, find cross-mapped pedagogical nodes
    const complianceNodeIds = complianceNodes.map(
      (n) => (n as Record<string, unknown>).id as string,
    );

    const { data: crossMappings, error: mapError } = await adminClient
      .from("curriculum_cross_mappings")
      .select("source_node_id, target_node_id")
      .or(
        `source_node_id.in.(${complianceNodeIds.join(",")}),` +
          `target_node_id.in.(${complianceNodeIds.join(",")})`,
      );

    if (mapError) {
      return failure(mapError.message, ErrorCodes.INTERNAL_ERROR);
    }

    // Build: complianceNodeId → [pedagogicalNodeId, ...]
    const complianceToSource = new Map<string, Set<string>>();
    const complianceNodeIdSet = new Set(complianceNodeIds);

    for (const mapping of crossMappings ?? []) {
      const m = mapping as Record<string, unknown>;
      const sourceId = m.source_node_id as string;
      const targetId = m.target_node_id as string;

      if (complianceNodeIdSet.has(targetId)) {
        // This compliance node is the target → source is the pedagogical node
        if (!complianceToSource.has(targetId))
          complianceToSource.set(targetId, new Set());
        complianceToSource.get(targetId)!.add(sourceId);
      }
      if (complianceNodeIdSet.has(sourceId)) {
        // This compliance node is the source → target is the pedagogical node
        if (!complianceToSource.has(sourceId))
          complianceToSource.set(sourceId, new Set());
        complianceToSource.get(sourceId)!.add(targetId);
      }
    }

    // 4. Collect all pedagogical node IDs we need to search evidence for
    const allPedagogicalNodeIds: string[] = [];
    for (const nodeIds of complianceToSource.values()) {
      for (const id of nodeIds) {
        allPedagogicalNodeIds.push(id);
      }
    }

    // 5. Also find tenant curriculum_nodes that were forked from these template nodes
    // (observations link to instance nodes, not template nodes)
    let instanceNodeMap = new Map<string, string>(); // template_node_id → instance_node_id

    if (allPedagogicalNodeIds.length > 0) {
      const { data: instanceNodes } = await supabase
        .from("curriculum_nodes")
        .select("id, source_template_node_id")
        .in("source_template_node_id", allPedagogicalNodeIds)
        .is("deleted_at", null);

      if (instanceNodes) {
        for (const node of instanceNodes) {
          const n = node as Record<string, unknown>;
          const templateNodeId = n.source_template_node_id as string;
          const instanceNodeId = n.id as string;
          instanceNodeMap.set(templateNodeId, instanceNodeId);
        }
      }
    }

    // 6. Fetch observation evidence
    const instanceNodeIds = [...instanceNodeMap.values()];
    const observationEvidence = new Map<string, ComplianceEvidence[]>(); // instanceNodeId → evidence[]

    if (instanceNodeIds.length > 0) {
      let obsQuery = supabase
        .from("observation_outcomes")
        .select(
          `
          curriculum_node_id,
          observation:observations!observation_outcomes_observation_id_fkey(
            id, content, published_at, status,
            observation_students:observation_students(
              student:students!observation_students_student_id_fkey(id, first_name, last_name)
            )
          )
        `,
        )
        .in("curriculum_node_id", instanceNodeIds);

      const { data: obsData } = await obsQuery;

      if (obsData) {
        for (const row of obsData) {
          const r = row as Record<string, unknown>;
          const nodeId = r.curriculum_node_id as string;
          const observation = unwrapJoin(r.observation);
          if (!observation) continue;

          // Only include published observations
          if ((observation.status as string) !== "published") continue;

          // Date filtering
          const publishedAt = observation.published_at as string;
          if (options?.from_date && publishedAt < options.from_date) continue;
          if (options?.to_date && publishedAt > options.to_date) continue;

          const students =
            (observation.observation_students as Array<
              Record<string, unknown>
            >) ?? [];

          for (const studentRow of students) {
            const student = unwrapJoin(studentRow.student);
            if (!student) continue;

            // Student filtering
            if (
              options?.student_id &&
              (student.id as string) !== options.student_id
            )
              continue;

            if (!observationEvidence.has(nodeId))
              observationEvidence.set(nodeId, []);
            observationEvidence.get(nodeId)!.push({
              type: "observation",
              id: observation.id as string,
              summary: truncate((observation.content as string) ?? "", 120),
              student_name:
                `${student.first_name ?? ""} ${student.last_name ?? ""}`.trim(),
              student_id: student.id as string,
              date: publishedAt,
              source_outcome: null, // Will be filled below
            });
          }
        }
      }
    }

    // 7. Fetch mastery evidence
    const masteryEvidence = new Map<string, ComplianceEvidence[]>();

    if (instanceNodeIds.length > 0) {
      let masteryQuery = supabase
        .from("student_mastery")
        .select(
          `
          id, curriculum_node_id, status, date_achieved,
          student:students!student_mastery_student_id_fkey(id, first_name, last_name)
        `,
        )
        .in("curriculum_node_id", instanceNodeIds)
        .in("status", ["practicing", "mastered"]);

      const { data: masteryData } = await masteryQuery;

      if (masteryData) {
        for (const row of masteryData) {
          const r = row as Record<string, unknown>;
          const nodeId = r.curriculum_node_id as string;
          const student = unwrapJoin(r.student);
          if (!student) continue;

          if (
            options?.student_id &&
            (student.id as string) !== options.student_id
          )
            continue;

          const dateAchieved = (r.date_achieved as string) ?? (r.id as string);
          if (options?.from_date && dateAchieved < options.from_date) continue;
          if (options?.to_date && dateAchieved > options.to_date) continue;

          if (!masteryEvidence.has(nodeId)) masteryEvidence.set(nodeId, []);
          masteryEvidence.get(nodeId)!.push({
            type: "mastery",
            id: r.id as string,
            summary: `Status: ${r.status as string}`,
            student_name:
              `${student.first_name ?? ""} ${student.last_name ?? ""}`.trim(),
            student_id: student.id as string,
            date: dateAchieved,
            source_outcome: null,
          });
        }
      }
    }

    // 8. Assemble the report — one item per compliance outcome
    const outcomes: ComplianceReportItem[] = [];
    let totalEvidence = 0;
    let withEvidence = 0;
    let withoutEvidence = 0;

    for (const complianceNode of complianceNodes) {
      const cn = complianceNode as Record<string, unknown>;
      const complianceNodeId = cn.id as string;

      const evidence: ComplianceEvidence[] = [];

      // Get all pedagogical nodes mapped to this compliance node
      const pedagogicalNodeIds =
        complianceToSource.get(complianceNodeId) ?? new Set();

      for (const pedNodeId of pedagogicalNodeIds) {
        // Find the instance node ID for this pedagogical template node
        const instanceNodeId = instanceNodeMap.get(pedNodeId);
        if (!instanceNodeId) continue;

        // Collect observation evidence
        const obsEvidence = observationEvidence.get(instanceNodeId) ?? [];
        evidence.push(...obsEvidence);

        // Collect mastery evidence
        const masEvidence = masteryEvidence.get(instanceNodeId) ?? [];
        evidence.push(...masEvidence);
      }

      // Sort evidence by date, newest first
      evidence.sort((a, b) => b.date.localeCompare(a.date));

      totalEvidence += evidence.length;
      if (evidence.length > 0) {
        withEvidence++;
      } else {
        withoutEvidence++;
      }

      outcomes.push({
        outcome_id: complianceNodeId,
        outcome_title: cn.title as string,
        outcome_code: (cn.code as string) ?? null,
        evidence_count: evidence.length,
        evidence,
      });
    }

    return success({
      framework,
      template_id: complianceTemplateId,
      template_name: templateName,
      generated_at: new Date().toISOString(),
      outcomes,
      total_evidence: totalEvidence,
      outcomes_with_evidence: withEvidence,
      outcomes_without_evidence: withoutEvidence,
    });
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Failed to generate compliance report";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// READ: Get prerequisite chain for a curriculum node
// ============================================================
// WHY: The prerequisite visualization feature shows directed
// dependencies between outcomes. Guides use this to understand
// what a child should have mastered before presenting a new work.
// ============================================================

export async function getPrerequisiteChain(
  nodeId: string,
  instanceId: string,
): Promise<ActionResponse<EnhancedCurriculumNode[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Fetch the starting node
    const { data: startNode, error: startError } = await supabase
      .from("curriculum_nodes")
      .select("*")
      .eq("id", nodeId)
      .eq("instance_id", instanceId)
      .is("deleted_at", null)
      .single();

    if (startError || !startNode) {
      return failure("Node not found", ErrorCodes.NOT_FOUND);
    }

    const typedStart = startNode as Record<string, unknown>;
    const prerequisites = (typedStart.prerequisites as string[]) ?? [];

    if (prerequisites.length === 0) {
      return success([]);
    }

    // Walk the prerequisite chain (max 10 levels to prevent infinite loops)
    const visited = new Set<string>();
    const chain: EnhancedCurriculumNode[] = [];
    let currentIds = [...prerequisites];
    let depth = 0;
    const maxDepth = 10;

    while (currentIds.length > 0 && depth < maxDepth) {
      const unvisited = currentIds.filter((id) => !visited.has(id));
      if (unvisited.length === 0) break;

      for (const id of unvisited) {
        visited.add(id);
      }

      const { data: nodes, error: nodesError } = await supabase
        .from("curriculum_nodes")
        .select("*")
        .in("id", unvisited)
        .eq("instance_id", instanceId)
        .is("deleted_at", null);

      if (nodesError || !nodes) break;

      const nextIds: string[] = [];
      for (const node of nodes) {
        const n = node as Record<string, unknown>;
        chain.push(n as unknown as EnhancedCurriculumNode);
        const nodePrereqs = (n.prerequisites as string[]) ?? [];
        nextIds.push(...nodePrereqs);
      }

      currentIds = nextIds;
      depth++;
    }

    return success(chain);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get prerequisite chain";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// READ: Get enriched node details with Module 14 columns
// ============================================================
// WHY: The existing getCurriculumTree returns basic node data.
// This returns a single node with all the enriched Module 14
// fields: materials, aims, prerequisites, assessment criteria.
// ============================================================

export async function getEnrichedNode(
  nodeId: string,
): Promise<ActionResponse<EnhancedCurriculumNode>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("curriculum_nodes")
      .select("*")
      .eq("id", nodeId)
      .is("deleted_at", null)
      .single();

    if (error || !data) {
      return failure("Node not found", ErrorCodes.NOT_FOUND);
    }

    return success(data as EnhancedCurriculumNode);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get enriched node";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// UPDATE: Set Module 14 enrichment fields on a curriculum node
// ============================================================
// WHY: Allows guides and curriculum managers to add/edit the
// Montessori-specific metadata: materials, aims, prerequisites.
// ============================================================

export interface UpdateNodeEnrichmentInput {
  code?: string | null;
  description?: string | null;
  materials?: string[] | null;
  direct_aims?: string[] | null;
  indirect_aims?: string[] | null;
  age_range?: string | null;
  prerequisites?: string[] | null;
  assessment_criteria?: string | null;
  content_url?: string | null;
}

export async function updateNodeEnrichment(
  nodeId: string,
  input: UpdateNodeEnrichmentInput,
): Promise<ActionResponse<EnhancedCurriculumNode>> {
  try {
    await requirePermission("manage_curriculum");
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.code !== undefined) updateData.code = input.code;
    if (input.description !== undefined)
      updateData.description = input.description;
    if (input.materials !== undefined) updateData.materials = input.materials;
    if (input.direct_aims !== undefined)
      updateData.direct_aims = input.direct_aims;
    if (input.indirect_aims !== undefined)
      updateData.indirect_aims = input.indirect_aims;
    if (input.age_range !== undefined) updateData.age_range = input.age_range;
    if (input.prerequisites !== undefined)
      updateData.prerequisites = input.prerequisites;
    if (input.assessment_criteria !== undefined)
      updateData.assessment_criteria = input.assessment_criteria;
    if (input.content_url !== undefined)
      updateData.content_url = input.content_url;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("curriculum_nodes")
      .update(updateData)
      .eq("id", nodeId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    if (!data) {
      return failure("Node not found", ErrorCodes.NOT_FOUND);
    }

    return success(data as EnhancedCurriculumNode);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update node enrichment";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// IMPORT: Import a JSON curriculum template with nodes and
// cross-mappings
// ============================================================
// WHY: Curriculum data is curated as JSON files in
// /packages/curriculum-templates/. This function takes a JSON
// template (matching the format in the design doc) and creates
// the template + all nodes + all cross-mappings in one operation.
//
// This is an admin-only operation — only Ecodia staff can
// import global templates.
// ============================================================

export interface ImportResult {
  template_id: string;
  nodes_created: number;
  cross_mappings_created: number;
  cross_mappings_skipped: number;
}

export async function importJsonTemplate(
  json: JsonTemplateImport,
): Promise<ActionResponse<ImportResult>> {
  try {
    const context = await requirePermission(PERM_MANAGE_TEMPLATES);
    const adminClient = createSupabaseAdminClient();

    // 1. Create or update the template
    const { data: existingTemplate } = await adminClient
      .from("curriculum_templates")
      .select("id")
      .eq("slug", json.slug)
      .single();

    let templateId: string;

    if (existingTemplate) {
      // Update existing template metadata
      const { error: updateError } = await adminClient
        .from("curriculum_templates")
        .update({
          name: json.name,
          framework: json.framework,
          age_range: json.age_range,
          country: json.country ?? "AU",
          state: json.state ?? null,
          version: json.version,
          is_compliance_framework: json.is_compliance_framework ?? false,
          is_active: true,
        })
        .eq("id", (existingTemplate as Record<string, unknown>).id as string);

      if (updateError) {
        return failure(
          `Failed to update template: ${updateError.message}`,
          ErrorCodes.INTERNAL_ERROR,
        );
      }

      templateId = (existingTemplate as Record<string, unknown>).id as string;

      // Soft-delete existing template nodes (will re-create)
      const { error: deleteError } = await adminClient
        .from("curriculum_template_nodes")
        .update({ deleted_at: new Date().toISOString() })
        .eq("template_id", templateId);

      if (deleteError) {
        return failure(
          `Failed to clear existing nodes: ${deleteError.message}`,
          ErrorCodes.INTERNAL_ERROR,
        );
      }
    } else {
      // Create new template
      const { data: newTemplate, error: createError } = await adminClient
        .from("curriculum_templates")
        .insert({
          slug: json.slug,
          name: json.name,
          framework: json.framework,
          age_range: json.age_range,
          country: json.country ?? "AU",
          state: json.state ?? null,
          version: json.version,
          is_compliance_framework: json.is_compliance_framework ?? false,
          is_active: true,
        })
        .select()
        .single();

      if (createError || !newTemplate) {
        return failure(
          `Failed to create template: ${createError?.message}`,
          ErrorCodes.INTERNAL_ERROR,
        );
      }

      templateId = (newTemplate as Record<string, unknown>).id as string;
    }

    // 2. Recursively insert nodes, collecting code → nodeId mappings for cross-mapping resolution
    const codeToNodeId = new Map<string, string>();
    let nodesCreated = 0;

    // Collect deferred cross-mappings (code-based references that need resolution)
    const deferredCrossMappings: Array<{
      source_node_id: string;
      target_framework: string;
      target_code: string;
      mapping_type: string;
    }> = [];

    async function insertNodes(
      nodes: JsonTemplateNode[],
      parentId: string | null,
      sequenceStart: number,
    ): Promise<void> {
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];

        const { data: insertedNode, error: insertError } = await adminClient
          .from("curriculum_template_nodes")
          .insert({
            template_id: templateId,
            parent_id: parentId,
            level: node.level,
            title: node.title,
            code: node.code ?? null,
            description: node.description ?? null,
            materials: node.materials ?? null,
            direct_aims: node.direct_aims ?? null,
            indirect_aims: node.indirect_aims ?? null,
            age_range: node.age_range ?? null,
            assessment_criteria: node.assessment_criteria ?? null,
            content_url: node.content_url ?? null,
            sequence_order: sequenceStart + i,
          })
          .select()
          .single();

        if (insertError || !insertedNode) continue;

        const insertedId = (insertedNode as Record<string, unknown>)
          .id as string;
        nodesCreated++;

        // Map code to node ID for cross-mapping resolution
        if (node.code) {
          codeToNodeId.set(node.code, insertedId);
        }

        // Collect cross-mapping references for deferred resolution
        if (node.cross_mappings) {
          for (const mapping of node.cross_mappings) {
            deferredCrossMappings.push({
              source_node_id: insertedId,
              target_framework: mapping.framework,
              target_code: mapping.code,
              mapping_type: mapping.type,
            });
          }
        }

        // Recurse into children
        if (node.children && node.children.length > 0) {
          await insertNodes(node.children, insertedId, 0);
        }
      }
    }

    await insertNodes(json.nodes, null, 0);

    // 3. Resolve deferred cross-mappings
    let crossMappingsCreated = 0;
    let crossMappingsSkipped = 0;

    if (deferredCrossMappings.length > 0) {
      // Collect all target codes we need to look up
      const targetCodes = [
        ...new Set(deferredCrossMappings.map((m) => m.target_code)),
      ];

      // Look up target nodes across all templates by code
      const { data: targetNodes } = await adminClient
        .from("curriculum_template_nodes")
        .select("id, code, template_id")
        .in("code", targetCodes)
        .not("code", "is", null);

      // Build code → {nodeId, templateId} map
      const codeToTarget = new Map<
        string,
        { nodeId: string; templateId: string }
      >();
      if (targetNodes) {
        for (const tn of targetNodes) {
          const t = tn as Record<string, unknown>;
          const code = t.code as string;
          // If multiple nodes have the same code, prefer the first one
          if (!codeToTarget.has(code)) {
            codeToTarget.set(code, {
              nodeId: t.id as string,
              templateId: t.template_id as string,
            });
          }
        }
      }

      // Create cross-mappings
      const crossMappingRows: Array<Record<string, unknown>> = [];

      for (const dm of deferredCrossMappings) {
        const target = codeToTarget.get(dm.target_code);
        if (!target) {
          crossMappingsSkipped++;
          continue;
        }

        crossMappingRows.push({
          tenant_id: null, // Global mapping
          source_template_id: templateId,
          source_node_id: dm.source_node_id,
          target_template_id: target.templateId,
          target_node_id: target.nodeId,
          mapping_type: dm.mapping_type || "aligned",
          confidence: "verified",
          notes: null,
          created_by: context.user.id,
        });
      }

      if (crossMappingRows.length > 0) {
        const { data: created } = await adminClient
          .from("curriculum_cross_mappings")
          .upsert(crossMappingRows, {
            onConflict: "source_node_id,target_node_id",
            ignoreDuplicates: true,
          })
          .select();

        crossMappingsCreated = (created ?? []).length;
        crossMappingsSkipped += crossMappingRows.length - crossMappingsCreated;
      }
    }

    return success({
      template_id: templateId,
      nodes_created: nodesCreated,
      cross_mappings_created: crossMappingsCreated,
      cross_mappings_skipped: crossMappingsSkipped,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to import template";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// Private Helpers
// ============================================================

/** Supabase returns joins as objects or arrays. Normalize to single object. */
function unwrapJoin(value: unknown): Record<string, unknown> | null {
  if (!value) return null;
  if (Array.isArray(value))
    return (value[0] as Record<string, unknown>) ?? null;
  return value as Record<string, unknown>;
}

/** Truncate a string to a max length, adding ellipsis if needed */
function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength - 3) + "...";
}


===== D:\.code\wattleos\src\lib\actions\curriculum-content\cross-mappings.ts =====

"use server";

// ============================================================
// WattleOS V2 — Module 14: Curriculum Cross-Mappings
// ============================================================
// Links outcomes between curriculum frameworks (e.g., AMI →
// EYLF, ACARA → QCAA). Global mappings (tenant_id IS NULL) are
// curated by Ecodia; tenant-specific overrides allow schools to
// add their own or adjust confidence levels.
//
// WHY cross-mappings exist: A Montessori school must track
// mastery against AMI curriculum (their pedagogy) AND map
// observations to EYLF outcomes (regulatory compliance for 0–5)
// AND report against ACARA (F–10) or QCAA (11–12). Cross-
// mappings automate this so guides tag once (AMI) and the system
// resolves all linked compliance outcomes.
// ============================================================

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import {
  createSupabaseAdminClient,
  createSupabaseServerClient,
} from "@/lib/supabase/server";
import type { ActionResponse } from "@/types/api";
import { ErrorCodes, failure, success } from "@/types/api";

// ============================================================
// Types
// ============================================================

export type CrossMappingType =
  | "aligned"
  | "partially_aligned"
  | "prerequisite"
  | "extends";
export type CrossMappingConfidence = "verified" | "suggested" | "community";

export interface CurriculumCrossMapping {
  id: string;
  tenant_id: string | null;
  source_template_id: string;
  source_node_id: string;
  target_template_id: string;
  target_node_id: string;
  mapping_type: CrossMappingType;
  confidence: CrossMappingConfidence;
  notes: string | null;
  created_by: string | null;
  created_at: string;
}

/** Cross-mapping with resolved node titles and template names for display */
export interface CrossMappingWithDetails extends CurriculumCrossMapping {
  source_node: {
    id: string;
    title: string;
    code: string | null;
    level: string;
  };
  source_template: {
    id: string;
    name: string;
    framework: string | null;
  };
  target_node: {
    id: string;
    title: string;
    code: string | null;
    level: string;
  };
  target_template: {
    id: string;
    name: string;
    framework: string | null;
  };
}

/** Lightweight linked outcome — returned for auto-tagging observations */
export interface LinkedOutcome {
  node_id: string;
  node_title: string;
  node_code: string | null;
  template_id: string;
  template_name: string;
  framework: string | null;
  mapping_type: CrossMappingType;
  confidence: CrossMappingConfidence;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateCrossMappingInput {
  source_template_id: string;
  source_node_id: string;
  target_template_id: string;
  target_node_id: string;
  mapping_type: CrossMappingType;
  confidence?: CrossMappingConfidence;
  notes?: string | null;
  /** If true, creates a global mapping (requires manage_curriculum_templates). Otherwise tenant-scoped. */
  is_global?: boolean;
}

export interface UpdateCrossMappingInput {
  mapping_type?: CrossMappingType;
  confidence?: CrossMappingConfidence;
  notes?: string | null;
}

export interface ListCrossMappingsFilter {
  /** Filter by source or target node ID */
  node_id?: string;
  /** Filter by source template */
  source_template_id?: string;
  /** Filter by target template */
  target_template_id?: string;
  /** Filter by mapping type */
  mapping_type?: CrossMappingType;
  /** Filter by confidence level */
  confidence?: CrossMappingConfidence;
  /** Include global mappings (default: true) */
  include_global?: boolean;
  /** Include tenant-specific overrides (default: true) */
  include_tenant?: boolean;
}

// ============================================================
// Permission keys (must match the seeded permissions)
// ============================================================

const PERM_MANAGE_CROSS_MAPPINGS = "manage_cross_mappings";
const PERM_MANAGE_CURRICULUM_TEMPLATES = "manage_curriculum_templates";

// ============================================================
// CREATE: Add a cross-mapping between two curriculum nodes
// ============================================================
// WHY tenant-scoped by default: Schools may discover additional
// alignments between their AMI outcomes and EYLF. Global
// mappings are curated centrally by Ecodia.
// ============================================================

export async function createCrossMapping(
  input: CreateCrossMappingInput,
): Promise<ActionResponse<CurriculumCrossMapping>> {
  try {
    const isGlobal = input.is_global === true;

    // Global mappings need system-level permission
    const permKey = isGlobal
      ? PERM_MANAGE_CURRICULUM_TEMPLATES
      : PERM_MANAGE_CROSS_MAPPINGS;
    const context = await requirePermission(permKey);

    const supabase = await createSupabaseServerClient();

    // Validate source and target nodes exist
    const adminClient = createSupabaseAdminClient();

    const [sourceNode, targetNode] = await Promise.all([
      adminClient
        .from("curriculum_nodes")
        .select("id")
        .eq("id", input.source_node_id)
        .single(),
      adminClient
        .from("curriculum_nodes")
        .select("id")
        .eq("id", input.target_node_id)
        .single(),
    ]);

    if (sourceNode.error || !sourceNode.data) {
      return failure("Source curriculum node not found", ErrorCodes.NOT_FOUND);
    }
    if (targetNode.error || !targetNode.data) {
      return failure("Target curriculum node not found", ErrorCodes.NOT_FOUND);
    }

    // Prevent self-mapping
    if (input.source_node_id === input.target_node_id) {
      return failure(
        "Cannot map a node to itself",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const insertData = {
      tenant_id: isGlobal ? null : context.tenant.id,
      source_template_id: input.source_template_id,
      source_node_id: input.source_node_id,
      target_template_id: input.target_template_id,
      target_node_id: input.target_node_id,
      mapping_type: input.mapping_type,
      confidence: input.confidence ?? "verified",
      notes: input.notes ?? null,
      created_by: context.user.id,
    };

    // Use admin client for global mappings (no tenant_id in RLS)
    const client = isGlobal ? adminClient : supabase;

    const { data, error } = await client
      .from("curriculum_cross_mappings")
      .insert(insertData)
      .select()
      .single();

    if (error) {
      if (error.code === "23505") {
        return failure(
          "A mapping between these two nodes already exists",
          ErrorCodes.CONFLICT,
        );
      }
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    return success(data as CurriculumCrossMapping);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create cross-mapping";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// UPDATE: Modify mapping type, confidence, or notes
// ============================================================

export async function updateCrossMapping(
  mappingId: string,
  input: UpdateCrossMappingInput,
): Promise<ActionResponse<CurriculumCrossMapping>> {
  try {
    await requirePermission(PERM_MANAGE_CROSS_MAPPINGS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.mapping_type !== undefined)
      updateData.mapping_type = input.mapping_type;
    if (input.confidence !== undefined)
      updateData.confidence = input.confidence;
    if (input.notes !== undefined) updateData.notes = input.notes;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    // Try tenant-scoped first
    const { data, error } = await supabase
      .from("curriculum_cross_mappings")
      .update(updateData)
      .eq("id", mappingId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    if (!data) {
      return failure(
        "Cross-mapping not found or not editable",
        ErrorCodes.NOT_FOUND,
      );
    }

    return success(data as CurriculumCrossMapping);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update cross-mapping";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// DELETE: Remove a cross-mapping
// ============================================================
// WHY hard delete (not soft): Cross-mappings are metadata links,
// not user content. Removing one just unlinks two outcomes. The
// UNIQUE constraint means we can re-create later if needed.
// ============================================================

export async function deleteCrossMapping(
  mappingId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(PERM_MANAGE_CROSS_MAPPINGS);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("curriculum_cross_mappings")
      .delete()
      .eq("id", mappingId);

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete cross-mapping";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// DELETE (Global): Remove a global cross-mapping
// ============================================================
// WHY separate function: Global mappings have tenant_id IS NULL,
// so tenant-scoped RLS won't match. Requires system permission.
// ============================================================

export async function deleteGlobalCrossMapping(
  mappingId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(PERM_MANAGE_CURRICULUM_TEMPLATES);
    const adminClient = createSupabaseAdminClient();

    const { error } = await adminClient
      .from("curriculum_cross_mappings")
      .delete()
      .eq("id", mappingId)
      .is("tenant_id", null);

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Failed to delete global cross-mapping";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// LIST: Get all cross-mappings for a specific node (both
// directions — where this node is source OR target)
// ============================================================
// WHY bidirectional: If AMI "Pouring" → EYLF 3.2, viewing the
// EYLF 3.2 node should also show the link back to AMI "Pouring".
// ============================================================

export async function listCrossMappingsForNode(
  nodeId: string,
): Promise<ActionResponse<CrossMappingWithDetails[]>> {
  try {
    await getTenantContext();
    const adminClient = createSupabaseAdminClient();

    // We use admin client because cross-mappings may be global (NULL tenant_id)
    // and we need to join across template tables that are also global.
    // RLS on curriculum_cross_mappings already allows SELECT on global rows.

    // Fetch mappings where this node is the source
    const { data: asSource, error: sourceError } = await adminClient
      .from("curriculum_cross_mappings")
      .select(
        `
        *,
        source_node:curriculum_nodes!curriculum_cross_mappings_source_node_id_fkey(id, title, code, level),
        source_template:curriculum_templates!curriculum_cross_mappings_source_template_id_fkey(id, name, framework),
        target_node:curriculum_nodes!curriculum_cross_mappings_target_node_id_fkey(id, title, code, level),
        target_template:curriculum_templates!curriculum_cross_mappings_target_template_id_fkey(id, name, framework)
      `,
      )
      .eq("source_node_id", nodeId);

    if (sourceError) {
      return failure(sourceError.message, ErrorCodes.INTERNAL_ERROR);
    }

    // Fetch mappings where this node is the target
    const { data: asTarget, error: targetError } = await adminClient
      .from("curriculum_cross_mappings")
      .select(
        `
        *,
        source_node:curriculum_nodes!curriculum_cross_mappings_source_node_id_fkey(id, title, code, level),
        source_template:curriculum_templates!curriculum_cross_mappings_source_template_id_fkey(id, name, framework),
        target_node:curriculum_nodes!curriculum_cross_mappings_target_node_id_fkey(id, title, code, level),
        target_template:curriculum_templates!curriculum_cross_mappings_target_template_id_fkey(id, name, framework)
      `,
      )
      .eq("target_node_id", nodeId);

    if (targetError) {
      return failure(targetError.message, ErrorCodes.INTERNAL_ERROR);
    }

    // Deduplicate by ID (a node could theoretically appear in both)
    const allMappings = [...(asSource ?? []), ...(asTarget ?? [])];
    const seen = new Set<string>();
    const deduplicated: CrossMappingWithDetails[] = [];

    for (const mapping of allMappings) {
      const row = mapping as Record<string, unknown>;
      const id = row.id as string;
      if (!seen.has(id)) {
        seen.add(id);
        deduplicated.push(normalizeMappingRow(row));
      }
    }

    return success(deduplicated);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list cross-mappings";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// LIST: Get all cross-mappings between two templates
// ============================================================
// WHY: The cross-mapping viewer UI needs to show all links
// between, say, "AMI Primary 3–6" and "EYLF v2" in a matrix.
// ============================================================

export async function listCrossMappingsBetweenTemplates(
  templateIdA: string,
  templateIdB: string,
): Promise<ActionResponse<CrossMappingWithDetails[]>> {
  try {
    await getTenantContext();
    const adminClient = createSupabaseAdminClient();

    // Get mappings in both directions between the two templates
    const { data, error } = await adminClient
      .from("curriculum_cross_mappings")
      .select(
        `
        *,
        source_node:curriculum_nodes!curriculum_cross_mappings_source_node_id_fkey(id, title, code, level),
        source_template:curriculum_templates!curriculum_cross_mappings_source_template_id_fkey(id, name, framework),
        target_node:curriculum_nodes!curriculum_cross_mappings_target_node_id_fkey(id, title, code, level),
        target_template:curriculum_templates!curriculum_cross_mappings_target_template_id_fkey(id, name, framework)
      `,
      )
      .or(
        `and(source_template_id.eq.${templateIdA},target_template_id.eq.${templateIdB}),` +
          `and(source_template_id.eq.${templateIdB},target_template_id.eq.${templateIdA})`,
      )
      .order("created_at", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    const mappings = (data ?? []).map((row) =>
      normalizeMappingRow(row as Record<string, unknown>),
    );

    return success(mappings);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list cross-mappings";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// LIST (Filtered): General-purpose cross-mapping query
// ============================================================

export async function listCrossMappings(
  filter: ListCrossMappingsFilter = {},
): Promise<ActionResponse<CrossMappingWithDetails[]>> {
  try {
    await getTenantContext();
    const adminClient = createSupabaseAdminClient();

    let query = adminClient.from("curriculum_cross_mappings").select(`
        *,
        source_node:curriculum_nodes!curriculum_cross_mappings_source_node_id_fkey(id, title, code, level),
        source_template:curriculum_templates!curriculum_cross_mappings_source_template_id_fkey(id, name, framework),
        target_node:curriculum_nodes!curriculum_cross_mappings_target_node_id_fkey(id, title, code, level),
        target_template:curriculum_templates!curriculum_cross_mappings_target_template_id_fkey(id, name, framework)
      `);

    if (filter.node_id) {
      query = query.or(
        `source_node_id.eq.${filter.node_id},target_node_id.eq.${filter.node_id}`,
      );
    }
    if (filter.source_template_id) {
      query = query.eq("source_template_id", filter.source_template_id);
    }
    if (filter.target_template_id) {
      query = query.eq("target_template_id", filter.target_template_id);
    }
    if (filter.mapping_type) {
      query = query.eq("mapping_type", filter.mapping_type);
    }
    if (filter.confidence) {
      query = query.eq("confidence", filter.confidence);
    }

    // Scope: global vs tenant
    if (filter.include_global === false && filter.include_tenant === false) {
      return success([]);
    }
    if (filter.include_global === false) {
      query = query.not("tenant_id", "is", null);
    }
    if (filter.include_tenant === false) {
      query = query.is("tenant_id", null);
    }

    const { data, error } = await query.order("created_at", {
      ascending: true,
    });

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    const mappings = (data ?? []).map((row) =>
      normalizeMappingRow(row as Record<string, unknown>),
    );

    return success(mappings);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list cross-mappings";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// RESOLVE: Get all linked compliance outcomes for a set of
// curriculum node IDs
// ============================================================
// WHY: This is the core compliance auto-tagging function. When
// a guide tags an observation with AMI outcomes, the system
// calls this to find all linked EYLF/ACARA/QCAA outcomes.
// The observation can then be automatically cross-tagged for
// compliance reporting.
//
// Returns outcomes grouped by framework for easy consumption.
// ============================================================

export interface LinkedOutcomesResult {
  /** All linked outcomes across all frameworks */
  outcomes: LinkedOutcome[];
  /** Outcomes grouped by framework name */
  by_framework: Record<string, LinkedOutcome[]>;
}

export async function resolveLinkedOutcomes(
  nodeIds: string[],
): Promise<ActionResponse<LinkedOutcomesResult>> {
  try {
    await getTenantContext();

    if (nodeIds.length === 0) {
      return success({ outcomes: [], by_framework: {} });
    }

    const adminClient = createSupabaseAdminClient();

    // Find all cross-mappings where any of these nodes is the source
    const { data: forwardMappings, error: fwdError } = await adminClient
      .from("curriculum_cross_mappings")
      .select(
        `
        target_node_id,
        target_template_id,
        mapping_type,
        confidence,
        target_node:curriculum_nodes!curriculum_cross_mappings_target_node_id_fkey(id, title, code),
        target_template:curriculum_templates!curriculum_cross_mappings_target_template_id_fkey(id, name, framework)
      `,
      )
      .in("source_node_id", nodeIds);

    if (fwdError) {
      return failure(fwdError.message, ErrorCodes.INTERNAL_ERROR);
    }

    // Also find reverse mappings (where these nodes are the target)
    const { data: reverseMappings, error: revError } = await adminClient
      .from("curriculum_cross_mappings")
      .select(
        `
        source_node_id,
        source_template_id,
        mapping_type,
        confidence,
        source_node:curriculum_nodes!curriculum_cross_mappings_source_node_id_fkey(id, title, code),
        source_template:curriculum_templates!curriculum_cross_mappings_source_template_id_fkey(id, name, framework)
      `,
      )
      .in("target_node_id", nodeIds);

    if (revError) {
      return failure(revError.message, ErrorCodes.INTERNAL_ERROR);
    }

    const outcomes: LinkedOutcome[] = [];
    const seen = new Set<string>();

    // Process forward mappings (source → target)
    for (const row of forwardMappings ?? []) {
      const r = row as Record<string, unknown>;
      const targetNode = unwrapJoin(r.target_node);
      const targetTemplate = unwrapJoin(r.target_template);
      if (!targetNode || !targetTemplate) continue;

      const nodeId = targetNode.id as string;
      if (seen.has(nodeId)) continue;
      seen.add(nodeId);

      outcomes.push({
        node_id: nodeId,
        node_title: targetNode.title as string,
        node_code: (targetNode.code as string) ?? null,
        template_id: targetTemplate.id as string,
        template_name: targetTemplate.name as string,
        framework: (targetTemplate.framework as string) ?? null,
        mapping_type: r.mapping_type as CrossMappingType,
        confidence: r.confidence as CrossMappingConfidence,
      });
    }

    // Process reverse mappings (target → source)
    for (const row of reverseMappings ?? []) {
      const r = row as Record<string, unknown>;
      const sourceNode = unwrapJoin(r.source_node);
      const sourceTemplate = unwrapJoin(r.source_template);
      if (!sourceNode || !sourceTemplate) continue;

      const nodeId = sourceNode.id as string;
      if (seen.has(nodeId)) continue;
      seen.add(nodeId);

      outcomes.push({
        node_id: nodeId,
        node_title: sourceNode.title as string,
        node_code: (sourceNode.code as string) ?? null,
        template_id: sourceTemplate.id as string,
        template_name: sourceTemplate.name as string,
        framework: (sourceTemplate.framework as string) ?? null,
        mapping_type: r.mapping_type as CrossMappingType,
        confidence: r.confidence as CrossMappingConfidence,
      });
    }

    // Group by framework
    const byFramework: Record<string, LinkedOutcome[]> = {};
    for (const outcome of outcomes) {
      const key = outcome.framework ?? "Unknown";
      if (!byFramework[key]) {
        byFramework[key] = [];
      }
      byFramework[key].push(outcome);
    }

    return success({ outcomes, by_framework: byFramework });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to resolve linked outcomes";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// BULK CREATE: Import multiple cross-mappings at once
// ============================================================
// WHY: When importing a JSON template with embedded cross_mappings,
// we need to create many mappings in one operation. Also used by
// the admin cross-mapping bulk editor.
// ============================================================

export interface BulkCrossMappingInput {
  source_node_id: string;
  target_node_id: string;
  source_template_id: string;
  target_template_id: string;
  mapping_type: CrossMappingType;
  confidence?: CrossMappingConfidence;
  notes?: string | null;
}

export interface BulkCreateResult {
  created: number;
  skipped: number;
  errors: string[];
}

export async function bulkCreateCrossMappings(
  mappings: BulkCrossMappingInput[],
  isGlobal: boolean = false,
): Promise<ActionResponse<BulkCreateResult>> {
  try {
    const permKey = isGlobal
      ? PERM_MANAGE_CURRICULUM_TEMPLATES
      : PERM_MANAGE_CROSS_MAPPINGS;
    const context = await requirePermission(permKey);

    if (mappings.length === 0) {
      return success({ created: 0, skipped: 0, errors: [] });
    }

    if (mappings.length > 500) {
      return failure(
        "Maximum 500 mappings per batch",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const client = isGlobal
      ? createSupabaseAdminClient()
      : await createSupabaseServerClient();

    const rows = mappings.map((m) => ({
      tenant_id: isGlobal ? null : context.tenant.id,
      source_template_id: m.source_template_id,
      source_node_id: m.source_node_id,
      target_template_id: m.target_template_id,
      target_node_id: m.target_node_id,
      mapping_type: m.mapping_type,
      confidence: m.confidence ?? "verified",
      notes: m.notes ?? null,
      created_by: context.user.id,
    }));

    // Use upsert with onConflict to skip duplicates
    const { data, error } = await client
      .from("curriculum_cross_mappings")
      .upsert(rows, {
        onConflict: "source_node_id,target_node_id",
        ignoreDuplicates: true,
      })
      .select();

    if (error) {
      return failure(error.message, ErrorCodes.INTERNAL_ERROR);
    }

    const created = (data ?? []).length;
    const skipped = mappings.length - created;

    return success({ created, skipped, errors: [] });
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Failed to bulk create cross-mappings";
    return failure(message, ErrorCodes.UNKNOWN_ERROR);
  }
}

// ============================================================
// Private Helpers
// ============================================================

/** Supabase returns joins as objects or arrays. Normalize to single object. */
function unwrapJoin(value: unknown): Record<string, unknown> | null {
  if (!value) return null;
  if (Array.isArray(value))
    return (value[0] as Record<string, unknown>) ?? null;
  return value as Record<string, unknown>;
}

/** Normalize a raw Supabase row with joined relations into CrossMappingWithDetails */
function normalizeMappingRow(
  row: Record<string, unknown>,
): CrossMappingWithDetails {
  const sourceNode = unwrapJoin(row.source_node);
  const sourceTemplate = unwrapJoin(row.source_template);
  const targetNode = unwrapJoin(row.target_node);
  const targetTemplate = unwrapJoin(row.target_template);

  return {
    id: row.id as string,
    tenant_id: (row.tenant_id as string) ?? null,
    source_template_id: row.source_template_id as string,
    source_node_id: row.source_node_id as string,
    target_template_id: row.target_template_id as string,
    target_node_id: row.target_node_id as string,
    mapping_type: row.mapping_type as CrossMappingType,
    confidence: row.confidence as CrossMappingConfidence,
    notes: (row.notes as string) ?? null,
    created_by: (row.created_by as string) ?? null,
    created_at: row.created_at as string,
    source_node: {
      id: (sourceNode?.id as string) ?? "",
      title: (sourceNode?.title as string) ?? "",
      code: (sourceNode?.code as string) ?? null,
      level: (sourceNode?.level as string) ?? "",
    },
    source_template: {
      id: (sourceTemplate?.id as string) ?? "",
      name: (sourceTemplate?.name as string) ?? "",
      framework: (sourceTemplate?.framework as string) ?? null,
    },
    target_node: {
      id: (targetNode?.id as string) ?? "",
      title: (targetNode?.title as string) ?? "",
      code: (targetNode?.code as string) ?? null,
      level: (targetNode?.level as string) ?? "",
    },
    target_template: {
      id: (targetTemplate?.id as string) ?? "",
      name: (targetTemplate?.name as string) ?? "",
      framework: (targetTemplate?.framework as string) ?? null,
    },
  };
}


===== D:\.code\wattleos\src\lib\actions\curriculum-content\index.ts =====

// ============================================================
// WattleOS V2 — Module 14: Curriculum Content Library
// ============================================================
// Barrel export for all curriculum content server actions.
// Split into two files by domain responsibility:
//   - cross-mappings: CRUD for inter-framework outcome links
//   - content-library: Enhanced queries, compliance reports, import
// ============================================================

export {
  bulkCreateCrossMappings,
  // Actions
  createCrossMapping,
  deleteCrossMapping,
  deleteGlobalCrossMapping,
  listCrossMappings,
  listCrossMappingsBetweenTemplates,
  listCrossMappingsForNode,
  resolveLinkedOutcomes,
  updateCrossMapping,
  type BulkCreateResult,
  type BulkCrossMappingInput,
  type CreateCrossMappingInput,
  type CrossMappingConfidence,
  type CrossMappingType,
  type CrossMappingWithDetails,
  // Types
  type CurriculumCrossMapping,
  type LinkedOutcome,
  type LinkedOutcomesResult,
  type ListCrossMappingsFilter,
  type UpdateCrossMappingInput,
} from "./cross-mappings";

export {
  generateComplianceReport,
  getEnrichedNode,
  getPrerequisiteChain,
  importJsonTemplate,
  listAvailableAgeRanges,
  listAvailableFrameworks,
  // Actions
  listTemplatesFiltered,
  searchNodesByCode,
  searchNodesByMaterial,
  updateNodeEnrichment,
  type ComplianceEvidence,
  type ComplianceReport,
  type ComplianceReportItem,
  type EnhancedCurriculumNode,
  // Types
  type EnhancedCurriculumTemplate,
  type ImportResult,
  type JsonTemplateImport,
  type JsonTemplateNode,
  type MaterialSearchResult,
  type TemplateFilter,
  type UpdateNodeEnrichmentInput,
} from "./content-library";


===== D:\.code\wattleos\src\lib\actions\enroll\enrollment-applications.ts =====

// src/lib/actions/enrollment-applications.ts
//
// ============================================================
// WattleOS V2 — Enrollment Application Server Actions (Module 10)
// ============================================================
// The heart of Module 10. Manages the full lifecycle of
// enrollment applications from submission through approval.
//
// The critical function is approveApplication() — a single
// server action that triggers a 12-step cascade creating the
// student record, guardian links, medical conditions, emergency
// contacts, custody restrictions, consent flags, and parent
// invitations. One click. Twelve outcomes. Zero re-entry.
//
// WHY server action (not DB trigger): The cascade involves
// business logic (token generation, date computation, consent
// mapping) that doesn't belong in SQL. Server actions also
// give us better error handling and audit trails.
//
// All actions return ActionResponse<T> — never throw.
// RLS enforces tenant isolation at the database level.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import {
  createSupabaseAdminClient,
  createSupabaseServerClient,
} from "@/lib/supabase/server";
import { validatePagination } from "@/lib/utils";
import {
  type ActionResponse,
  ErrorCodes,
  failure,
  paginated,
  paginatedFailure,
  type PaginatedResponse,
  success,
} from "@/types/api";
import type {
  ApplicationCustodyRestriction,
  ApplicationEmergencyContact,
  ApplicationGuardian,
  ApplicationMedicalCondition,
  ApplicationStatus,
  ApplicationWithDetails,
  EnrollmentApplication,
} from "@/types/domain";

// ============================================================
// Input Types
// ============================================================

export interface SubmitApplicationInput {
  enrollment_period_id: string;
  submitted_by_email: string;

  // Child info
  child_first_name: string;
  child_last_name: string;
  child_preferred_name?: string | null;
  child_date_of_birth: string;
  child_gender?: string | null;
  child_nationality?: string | null;
  child_languages?: string[];
  child_previous_school?: string | null;

  // Program preferences
  requested_program?: string | null;
  requested_start_date?: string | null;

  // Re-enrollment
  existing_student_id?: string | null;

  // Guardian data
  guardians: ApplicationGuardian[];

  // Medical data
  medical_conditions?: ApplicationMedicalCondition[];

  // Emergency contacts
  emergency_contacts: ApplicationEmergencyContact[];

  // Custody
  custody_restrictions?: ApplicationCustodyRestriction[];

  // Consents
  media_consent: boolean;
  directory_consent: boolean;
  terms_accepted: boolean;
  privacy_accepted: boolean;

  // Custom fields
  custom_responses?: Record<string, unknown>;
}

export interface ListApplicationsParams {
  page?: number;
  per_page?: number;
  status?: ApplicationStatus;
  enrollment_period_id?: string;
  search?: string;
}

export interface ReviewApplicationInput {
  admin_notes?: string | null;
  approved_class_id?: string | null;
}

// ============================================================
// Helpers (local)
// ============================================================

function firstOrNull<T>(v: T | T[] | null | undefined): T | null {
  if (!v) return null;
  return Array.isArray(v) ? (v[0] ?? null) : v;
}

// ============================================================
// LIST APPLICATIONS (Admin — paginated)
// ============================================================
export async function listEnrollmentApplications(
  params?: ListApplicationsParams,
): Promise<PaginatedResponse<EnrollmentApplication>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const supabase = await createSupabaseServerClient();

    // validatePagination returns { page, perPage, offset }
    const { page, perPage, offset } = validatePagination(params?.page, params?.per_page);
    const from = offset;
    const to = offset + perPage - 1;

    let query = supabase
      .from("enrollment_applications")
      .select("*", { count: "exact" })
      .is("deleted_at", null)
      .order("submitted_at", { ascending: false, nullsFirst: false })
      .order("created_at", { ascending: false });

    if (params?.status) {
      query = query.eq("status", params.status);
    }
    if (params?.enrollment_period_id) {
      query = query.eq("enrollment_period_id", params.enrollment_period_id);
    }
    if (params?.search) {
      const term = `%${params.search}%`;
      query = query.or(
        `child_first_name.ilike.${term},child_last_name.ilike.${term},submitted_by_email.ilike.${term}`,
      );
    }

    const { data, error, count } = await query.range(from, to);

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;

    // paginated expects (items, total, page, perPage)
    return paginated((data ?? []) as EnrollmentApplication[], total, page, perPage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list applications";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET APPLICATION WITH FULL DETAILS (Admin review screen)
// ============================================================

export async function getApplicationDetails(
  applicationId: string,
): Promise<ActionResponse<ApplicationWithDetails>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_applications")
      .select(
        `
        *,
        enrollment_period:enrollment_periods(id, name, year, period_type),
        documents:enrollment_documents(
          id, document_type, file_name, storage_path, mime_type,
          file_size_bytes, uploaded_by_email, verified, verified_by,
          verified_at, notes, created_at
        ),
        reviewer:users!enrollment_applications_reviewed_by_fkey(id, first_name, last_name),
        existing_student:students!enrollment_applications_existing_student_id_fkey(id, first_name, last_name),
        requested_class:classes!enrollment_applications_requested_class_id_fkey(id, name)
      `,
      )
      .eq("id", applicationId)
      .is("deleted_at", null)
      .single();

    if (error || !data) {
      return failure(error?.message ?? "Not found", ErrorCodes.NOT_FOUND);
    }

    // Supabase nested selects sometimes come back as arrays depending on relationship config.
    const enrollment_period = firstOrNull<any>(data.enrollment_period);
    const reviewer = firstOrNull<any>(data.reviewer);
    const existing_student = firstOrNull<any>(data.existing_student);
    const requested_class = firstOrNull<any>(data.requested_class);

    const documentsRaw = (data as any).documents;
    const documents = Array.isArray(documentsRaw) ? documentsRaw : (documentsRaw ? [documentsRaw] : []);

    const {
      enrollment_period: _ep,
      documents: _docs,
      reviewer: _rev,
      existing_student: _es,
      requested_class: _rc,
      ...application
    } = data as any;

    return success({
      ...application,
      enrollment_period:
        enrollment_period ?? {
          id: "",
          name: "",
          year: 0,
          period_type: "new_enrollment",
        },
      documents,
      reviewer: reviewer ?? null,
      existing_student: existing_student ?? null,
      requested_class: requested_class ?? null,
    } as ApplicationWithDetails);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get application details";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// SUBMIT APPLICATION (Public — from enrollment form)
// ============================================================
// Can be called by unauthenticated parents. The enrollment
// period must be open. RLS policy validates this on INSERT.

export async function submitEnrollmentApplication(
  tenantId: string,
  input: SubmitApplicationInput,
): Promise<ActionResponse<EnrollmentApplication>> {
  try {
    const supabase = await createSupabaseServerClient();

    // Validate required fields
    if (!input.child_first_name?.trim() || !input.child_last_name?.trim()) {
      return failure("Child name is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.child_date_of_birth) {
      return failure("Child date of birth is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.submitted_by_email?.trim()) {
      return failure("Parent email is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.guardians || input.guardians.length === 0) {
      return failure("At least one guardian is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.emergency_contacts || input.emergency_contacts.length < 2) {
      return failure("At least two emergency contacts are required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.terms_accepted || !input.privacy_accepted) {
      return failure("Terms and privacy policy must be accepted", ErrorCodes.VALIDATION_ERROR);
    }

    const now = new Date().toISOString();

    const { data, error } = await supabase
      .from("enrollment_applications")
      .insert({
        tenant_id: tenantId,
        enrollment_period_id: input.enrollment_period_id,
        status: "submitted",
        submitted_by_email: input.submitted_by_email.trim().toLowerCase(),
        submitted_at: now,
        child_first_name: input.child_first_name.trim(),
        child_last_name: input.child_last_name.trim(),
        child_preferred_name: input.child_preferred_name?.trim() ?? null,
        child_date_of_birth: input.child_date_of_birth,
        child_gender: input.child_gender ?? null,
        child_nationality: input.child_nationality ?? null,
        child_languages: input.child_languages ?? null,
        child_previous_school: input.child_previous_school?.trim() ?? null,
        requested_program: input.requested_program ?? null,
        requested_start_date: input.requested_start_date ?? null,
        existing_student_id: input.existing_student_id ?? null,
        guardians: input.guardians,
        medical_conditions: input.medical_conditions ?? [],
        emergency_contacts: input.emergency_contacts,
        custody_restrictions: input.custody_restrictions ?? [],
        media_consent: input.media_consent,
        directory_consent: input.directory_consent,
        terms_accepted: input.terms_accepted,
        terms_accepted_at: now,
        privacy_accepted: input.privacy_accepted,
        custom_responses: input.custom_responses ?? {},
      })
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as EnrollmentApplication);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to submit application";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE APPLICATION STATUS — Request Changes
// ============================================================

export async function requestApplicationChanges(
  applicationId: string,
  changeNotes: string,
): Promise<ActionResponse<EnrollmentApplication>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (!changeNotes?.trim()) {
      return failure("Change request notes are required", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("enrollment_applications")
      .update({
        status: "changes_requested",
        change_request_notes: changeNotes.trim(),
        reviewed_by: context.user.id,
        reviewed_at: new Date().toISOString(),
      })
      .eq("id", applicationId)
      .in("status", ["submitted", "under_review"])
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentApplication);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to request changes";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// REJECT APPLICATION
// ============================================================

export async function rejectApplication(
  applicationId: string,
  rejectionReason: string,
): Promise<ActionResponse<EnrollmentApplication>> {
  try {
    await requirePermission(Permissions.APPROVE_APPLICATIONS);
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (!rejectionReason?.trim()) {
      return failure("Rejection reason is required", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("enrollment_applications")
      .update({
        status: "rejected",
        rejection_reason: rejectionReason.trim(),
        reviewed_by: context.user.id,
        reviewed_at: new Date().toISOString(),
      })
      .eq("id", applicationId)
      .in("status", ["submitted", "under_review", "changes_requested"])
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentApplication);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to reject application";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// APPROVE APPLICATION — THE CASCADE
// ============================================================

export interface ApproveApplicationInput {
  approved_class_id: string;
  admin_notes?: string | null;
}

export interface ApprovalResult {
  application: EnrollmentApplication;
  student_id: string;
  invitation_count: number;
}

export async function approveApplication(
  applicationId: string,
  input: ApproveApplicationInput,
): Promise<ActionResponse<ApprovalResult>> {
  try {
    await requirePermission(Permissions.APPROVE_APPLICATIONS);
    const context = await getTenantContext();
    const tenantId = context.tenant.id;
    const userId = context.user.id;

    if (!input.approved_class_id) {
      return failure("A class must be assigned before approval", ErrorCodes.VALIDATION_ERROR);
    }

    // Use admin client for cross-table cascade
    const admin = createSupabaseAdminClient();

    // 1. Fetch the full application
    const { data: app, error: appError } = await admin
      .from("enrollment_applications")
      .select("*")
      .eq("id", applicationId)
      .is("deleted_at", null)
      .single();

    if (appError || !app) {
      return failure("Application not found", ErrorCodes.NOT_FOUND);
    }

    if (!["submitted", "under_review", "changes_requested"].includes(app.status)) {
      return failure(
        `Cannot approve an application with status "${app.status}"`,
        ErrorCodes.INVALID_STATUS_TRANSITION,
      );
    }

    const guardians = (app.guardians ?? []) as ApplicationGuardian[];
    const medicalConditions = (app.medical_conditions ?? []) as ApplicationMedicalCondition[];
    const emergencyContacts = (app.emergency_contacts ?? []) as ApplicationEmergencyContact[];
    const custodyRestrictions = (app.custody_restrictions ?? []) as ApplicationCustodyRestriction[];

    // ── Step 1: Create or update student record ────────────────
    let studentId: string;

    if (app.existing_student_id) {
      // Re-enrollment: update existing student
      studentId = app.existing_student_id;

      await admin
        .from("students")
        .update({
          preferred_name: app.child_preferred_name,
          gender: app.child_gender,
          enrollment_status: "active",
        })
        .eq("id", studentId);
    } else {
      // New enrollment: create student
      const { data: student, error: studentError } = await admin
        .from("students")
        .insert({
          tenant_id: tenantId,
          first_name: app.child_first_name,
          last_name: app.child_last_name,
          preferred_name: app.child_preferred_name,
          dob: app.child_date_of_birth,
          gender: app.child_gender,
          enrollment_status: "active",
        })
        .select("id")
        .single();

      if (studentError || !student) {
        return failure(
          `Failed to create student record: ${studentError?.message ?? "unknown"}`,
          ErrorCodes.CREATE_FAILED,
        );
      }

      studentId = student.id;
    }

    // ── Step 2: Create enrollment record ───────────────────────
    const startDate = app.requested_start_date ?? new Date().toISOString().split("T")[0];

    await admin.from("enrollments").insert({
      tenant_id: tenantId,
      student_id: studentId,
      class_id: input.approved_class_id,
      start_date: startDate,
      status: "active",
    });

    // ── Step 3: Create guardian records ─────────────────────────
    for (const g of guardians) {
      const email = (g.email ?? "").toLowerCase().trim();
      if (!email) continue;

      // Check if user exists with this email
      const { data: existingUser } = await admin
        .from("users")
        .select("id")
        .eq("email", email)
        .maybeSingle();

      const guardianUserId = existingUser?.id;

      // Only create guardian link if we have a user ID
      // (if no user exists yet, the parent invitation flow will handle it)
      if (guardianUserId) {
        await admin.from("guardians").upsert(
          {
            tenant_id: tenantId,
            user_id: guardianUserId,
            student_id: studentId,
            relationship: g.relationship,
            is_primary: g.is_primary,
            is_emergency_contact: g.is_emergency_contact,
            pickup_authorized: g.pickup_authorized,
            phone: g.phone,
            media_consent: app.media_consent,
            directory_consent: app.directory_consent,
          },
          {
            onConflict: "tenant_id,user_id,student_id",
            ignoreDuplicates: false,
          },
        );
      }
    }

    // ── Step 4: Create medical_conditions records ──────────────
    if (medicalConditions.length > 0) {
      const medicalRows = medicalConditions.map((mc) => ({
        tenant_id: tenantId,
        student_id: studentId,
        condition_type: mc.condition_type,
        condition_name: mc.condition_name,
        severity: mc.severity,
        description: mc.description,
        action_plan: mc.action_plan,
        requires_medication: mc.requires_medication,
        medication_name: mc.medication_name,
        medication_location: mc.medication_location,
      }));

      await admin.from("medical_conditions").insert(medicalRows);
    }

    // ── Step 5: Create emergency_contacts records ──────────────
    if (emergencyContacts.length > 0) {
      const contactRows = emergencyContacts.map((ec) => ({
        tenant_id: tenantId,
        student_id: studentId,
        name: ec.name,
        relationship: ec.relationship,
        phone_primary: ec.phone_primary,
        phone_secondary: ec.phone_secondary,
        email: ec.email,
        priority_order: ec.priority_order,
      }));

      await admin.from("emergency_contacts").insert(contactRows);
    }

    // ── Step 6: Create custody_restrictions records ─────────────
    if (custodyRestrictions.length > 0) {
      const restrictionRows = custodyRestrictions.map((cr) => ({
        tenant_id: tenantId,
        student_id: studentId,
        restricted_person_name: cr.restricted_person_name,
        restriction_type: cr.restriction_type,
        court_order_reference: cr.court_order_reference,
        notes: cr.notes,
        effective_date: new Date().toISOString().split("T")[0],
      }));

      await admin.from("custody_restrictions").insert(restrictionRows);
    }

    // ── Step 7: Generate parent invitations ─────────────────────
    let invitationCount = 0;
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 14);

    for (const g of guardians) {
      const email = (g.email ?? "").toLowerCase().trim();
      if (!email) continue;

      const token = generateSecureToken();

      const { error: inviteError } = await admin.from("parent_invitations").insert({
        tenant_id: tenantId,
        email,
        student_id: studentId,
        invited_by: userId,
        token,
        status: "pending",
        expires_at: expiresAt.toISOString(),
      });

      if (!inviteError) {
        invitationCount++;
        continue;
      }

      // Ignore duplicate invite errors (unique constraint)
      // Postgres duplicate key is 23505 in many setups; Supabase may surface as "23505".
      if (inviteError.code === "23505") {
        continue;
      }
      // Anything else is a real failure
      return failure(inviteError.message, ErrorCodes.CREATE_FAILED);
    }

    // ── Step 8: Update the application as approved ──────────────
    const { data: updatedApp, error: updateError } = await admin
      .from("enrollment_applications")
      .update({
        status: "approved",
        reviewed_by: userId,
        reviewed_at: new Date().toISOString(),
        admin_notes: input.admin_notes ?? null,
        created_student_id: studentId,
        approved_class_id: input.approved_class_id,
      })
      .eq("id", applicationId)
      .select("*")
      .single();

    if (updateError || !updatedApp) {
      return failure(
        `Student created but application update failed: ${updateError?.message ?? "unknown"}`,
        ErrorCodes.UPDATE_FAILED,
      );
    }

    return success({
      application: updatedApp as EnrollmentApplication,
      student_id: studentId,
      invitation_count: invitationCount,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to approve application";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// MARK APPLICATION AS UNDER REVIEW
// ============================================================

export async function markUnderReview(
  applicationId: string,
): Promise<ActionResponse<EnrollmentApplication>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_applications")
      .update({
        status: "under_review",
        reviewed_by: context.user.id,
        reviewed_at: new Date().toISOString(),
      })
      .eq("id", applicationId)
      .eq("status", "submitted")
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentApplication);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to mark as under review";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// WITHDRAW APPLICATION (Parent action)
// ============================================================

export async function withdrawApplication(
  applicationId: string,
): Promise<ActionResponse<EnrollmentApplication>> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_applications")
      .update({ status: "withdrawn" })
      .eq("id", applicationId)
      .in("status", ["draft", "submitted", "changes_requested"])
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentApplication);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to withdraw application";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET APPLICATION STATUS (Parent — by email)
// ============================================================

export async function getApplicationStatusByEmail(
  tenantId: string,
  email: string,
): Promise<
  ActionResponse<
    Array<
      Pick<
        EnrollmentApplication,
        | "id"
        | "status"
        | "child_first_name"
        | "child_last_name"
        | "submitted_at"
        | "change_request_notes"
        | "rejection_reason"
      >
    >
  >
> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_applications")
      .select(
        "id, status, child_first_name, child_last_name, submitted_at, change_request_notes, rejection_reason",
      )
      .eq("tenant_id", tenantId)
      .eq("submitted_by_email", email.toLowerCase())
      .is("deleted_at", null)
      .order("submitted_at", { ascending: false });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success(data ?? []);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get application status";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// Helpers
// ============================================================

/**
 * Generates a URL-safe random token for parent invitations.
 * 32 bytes → 43 characters base64url (collision-resistant).
 */
function generateSecureToken(): string {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  // Base64url encode (no padding)
  return btoa(String.fromCharCode(...bytes))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
}


===== D:\.code\wattleos\src\lib\actions\enroll\enrollment-documents.ts =====

// src/lib/actions/enrollment-documents.ts
//
// ============================================================
// WattleOS V2 — Enrollment Document Server Actions (Module 10)
// ============================================================
// Handles document uploads attached to enrollment applications.
// Documents are stored in Supabase Storage; this module manages
// the metadata records and admin verification workflow.
//
// WHY separate from enrollment-applications.ts: Documents have
// their own CRUD lifecycle (upload, verify, replace) independent
// of application status transitions. Keeping them separate
// avoids bloating the application actions file.
//
// All actions return ActionResponse<T> — never throw.
// RLS enforces tenant isolation at the database level.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { type ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type { EnrollmentDocument } from "@/types/domain";

// ============================================================
// Input Types
// ============================================================

export interface CreateDocumentInput {
  application_id: string;
  document_type: string;
  file_name: string;
  storage_path: string;
  mime_type: string;
  file_size_bytes: number;
  uploaded_by_email: string;
}

// ============================================================
// LIST DOCUMENTS FOR AN APPLICATION
// ============================================================

export async function listApplicationDocuments(
  applicationId: string,
): Promise<ActionResponse<EnrollmentDocument[]>> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_documents")
      .select("*")
      .eq("application_id", applicationId)
      .is("deleted_at", null)
      .order("document_type", { ascending: true })
      .order("created_at", { ascending: false });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as EnrollmentDocument[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list documents";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CREATE DOCUMENT RECORD
// ============================================================
// Called after the file has been uploaded to Supabase Storage.
// The frontend uploads the file first, gets the storage_path,
// then calls this to create the metadata record.

export async function createEnrollmentDocument(
  tenantId: string,
  input: CreateDocumentInput,
): Promise<ActionResponse<EnrollmentDocument>> {
  try {
    const supabase = await createSupabaseServerClient();

    // Validate required fields
    if (!input.application_id) {
      return failure("Application ID is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.document_type?.trim()) {
      return failure("Document type is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.file_name?.trim()) {
      return failure("File name is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.storage_path?.trim()) {
      return failure("Storage path is required", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("enrollment_documents")
      .insert({
        tenant_id: tenantId,
        application_id: input.application_id,
        document_type: input.document_type.trim(),
        file_name: input.file_name.trim(),
        storage_path: input.storage_path.trim(),
        mime_type: input.mime_type,
        file_size_bytes: input.file_size_bytes,
        uploaded_by_email: input.uploaded_by_email.toLowerCase(),
      })
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as EnrollmentDocument);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create document record";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// VERIFY DOCUMENT (Admin)
// ============================================================
// Admin marks a document as verified after reviewing it.
// This is a compliance requirement — schools must verify
// immunization records and court orders are authentic.

export async function verifyDocument(
  documentId: string,
): Promise<ActionResponse<EnrollmentDocument>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_documents")
      .update({
        verified: true,
        verified_by: context.user.id,
        verified_at: new Date().toISOString(),
      })
      .eq("id", documentId)
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentDocument);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to verify document";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UNVERIFY DOCUMENT (Admin)
// ============================================================
// Reverses verification if admin made an error or document
// needs to be replaced.

export async function unverifyDocument(
  documentId: string,
): Promise<ActionResponse<EnrollmentDocument>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_documents")
      .update({
        verified: false,
        verified_by: null,
        verified_at: null,
      })
      .eq("id", documentId)
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentDocument);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to unverify document";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// ADD NOTE TO DOCUMENT (Admin)
// ============================================================
// Admin can add notes to a document (e.g., "Expiry date:
// 2027-03-15" or "Missing page 2").

export async function updateDocumentNotes(
  documentId: string,
  notes: string | null,
): Promise<ActionResponse<EnrollmentDocument>> {
  try {
    await requirePermission(Permissions.REVIEW_APPLICATIONS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_documents")
      .update({ notes: notes?.trim() ?? null })
      .eq("id", documentId)
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentDocument);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update document notes";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// SOFT DELETE DOCUMENT
// ============================================================
// Removes the metadata record. The actual file in Supabase
// Storage should be cleaned up by a separate garbage collection
// process (or left in place for audit trail).

export async function deleteEnrollmentDocument(
  documentId: string,
): Promise<ActionResponse<{ id: string }>> {
  try {
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("enrollment_documents")
      .update({ deleted_at: new Date().toISOString() })
      .eq("id", documentId)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ id: documentId });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete document";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\enroll\enrollment-periods.ts =====

// src/lib/actions/enrollment-periods.ts
//
// ============================================================
// WattleOS V2 — Enrollment Period Server Actions (Module 10)
// ============================================================
// Manages enrollment windows: when schools accept new or
// re-enrollment applications. Admins create periods, configure
// required documents and custom fields, then open them for
// parent submissions.
//
// WHY separate from enrollment-applications.ts: Periods are
// configuration. Applications are transactional. Different
// access patterns and permission requirements.
//
// All actions return ActionResponse<T> — never throw.
// RLS enforces tenant isolation at the database level.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { type ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type {
  CustomField,
  EnrollmentPeriod,
  EnrollmentPeriodStatus,
} from "@/types/domain";

// ============================================================
// Input Types
// ============================================================

export interface CreateEnrollmentPeriodInput {
  name: string;
  period_type: "new_enrollment" | "re_enrollment" | "mid_year";
  year: number;
  opens_at: string;
  closes_at?: string | null;
  available_programs?: string[];
  required_documents?: string[];
  custom_fields?: CustomField[];
  welcome_message?: string | null;
  confirmation_message?: string | null;
}

export interface UpdateEnrollmentPeriodInput {
  name?: string;
  period_type?: "new_enrollment" | "re_enrollment" | "mid_year";
  year?: number;
  opens_at?: string;
  closes_at?: string | null;
  status?: EnrollmentPeriodStatus;
  available_programs?: string[];
  required_documents?: string[];
  custom_fields?: CustomField[];
  welcome_message?: string | null;
  confirmation_message?: string | null;
}

/** Period with application count stats for the admin list view */
export interface EnrollmentPeriodWithStats extends EnrollmentPeriod {
  total_applications: number;
  submitted_count: number;
  approved_count: number;
  rejected_count: number;
}

// ============================================================
// LIST ENROLLMENT PERIODS
// ============================================================
// Returns all periods for the current tenant, optionally
// filtered by year or status. Includes application counts.

export async function listEnrollmentPeriods(params?: {
  year?: number;
  status?: EnrollmentPeriodStatus;
}): Promise<ActionResponse<EnrollmentPeriodWithStats[]>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    let query = supabase
      .from("enrollment_periods")
      .select(
        `
        *,
        enrollment_applications(id, status)
      `,
      )
      .is("deleted_at", null)
      .order("year", { ascending: false })
      .order("opens_at", { ascending: false });

    if (params?.year) {
      query = query.eq("year", params.year);
    }
    if (params?.status) {
      query = query.eq("status", params.status);
    }

    const { data, error } = await query;

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Compute stats from nested applications
    const periods: EnrollmentPeriodWithStats[] = (data ?? []).map((row) => {
      const apps = (row.enrollment_applications ?? []) as Array<{
        id: string;
        status: string;
      }>;
      const { enrollment_applications: _, ...period } = row;
      return {
        ...period,
        total_applications: apps.length,
        submitted_count: apps.filter((a) => a.status === "submitted").length,
        approved_count: apps.filter((a) => a.status === "approved").length,
        rejected_count: apps.filter((a) => a.status === "rejected").length,
      } as EnrollmentPeriodWithStats;
    });

    return success(periods);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list enrollment periods";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET ENROLLMENT PERIOD BY ID
// ============================================================

export async function getEnrollmentPeriod(
  periodId: string,
): Promise<ActionResponse<EnrollmentPeriodWithStats>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_periods")
      .select(
        `
        *,
        enrollment_applications(id, status)
      `,
      )
      .eq("id", periodId)
      .is("deleted_at", null)
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.NOT_FOUND);
    }

    const apps = (data.enrollment_applications ?? []) as Array<{
      id: string;
      status: string;
    }>;
    const { enrollment_applications: _, ...period } = data;

    return success({
      ...period,
      total_applications: apps.length,
      submitted_count: apps.filter((a) => a.status === "submitted").length,
      approved_count: apps.filter((a) => a.status === "approved").length,
      rejected_count: apps.filter((a) => a.status === "rejected").length,
    } as EnrollmentPeriodWithStats);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET OPEN PERIODS (PUBLIC — no auth required)
// ============================================================
// Used by the public enrollment form to show which periods
// are currently accepting applications. RLS allows SELECT
// on open periods without authentication.

export async function getOpenEnrollmentPeriods(
  tenantId: string,
): Promise<ActionResponse<EnrollmentPeriod[]>> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("enrollment_periods")
      .select("*")
      .eq("tenant_id", tenantId)
      .eq("status", "open")
      .is("deleted_at", null)
      .order("opens_at", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Filter to only currently-active periods (opened and not yet closed)
    const now = new Date().toISOString();
    const activePeriods = (data ?? []).filter((p) => {
      if (p.opens_at > now) return false;
      if (p.closes_at && p.closes_at < now) return false;
      return true;
    }) as EnrollmentPeriod[];

    return success(activePeriods);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get open periods";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CREATE ENROLLMENT PERIOD
// ============================================================

export async function createEnrollmentPeriod(
  input: CreateEnrollmentPeriodInput,
): Promise<ActionResponse<EnrollmentPeriod>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Validate required fields
    if (!input.name?.trim()) {
      return failure("Period name is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.opens_at) {
      return failure("Opening date is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (input.year < 2020 || input.year > 2100) {
      return failure(
        "Year must be between 2020 and 2100",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("enrollment_periods")
      .insert({
        tenant_id: context.tenant.id,
        name: input.name.trim(),
        period_type: input.period_type,
        year: input.year,
        opens_at: input.opens_at,
        closes_at: input.closes_at ?? null,
        status: "draft",
        available_programs: input.available_programs ?? [],
        required_documents: input.required_documents ?? [],
        custom_fields: input.custom_fields ?? [],
        welcome_message: input.welcome_message ?? null,
        confirmation_message: input.confirmation_message ?? null,
      })
      .select("*")
      .single();

    if (error) {
      if (error.code === "23505") {
        return failure(
          `An enrollment period named "${input.name}" already exists for ${input.year}`,
          ErrorCodes.ALREADY_EXISTS,
        );
      }
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as EnrollmentPeriod);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE ENROLLMENT PERIOD
// ============================================================

export async function updateEnrollmentPeriod(
  periodId: string,
  input: UpdateEnrollmentPeriodInput,
): Promise<ActionResponse<EnrollmentPeriod>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    // Build the update payload (only include provided fields)
    const updates: Record<string, unknown> = {};
    if (input.name !== undefined) updates.name = input.name.trim();
    if (input.period_type !== undefined)
      updates.period_type = input.period_type;
    if (input.year !== undefined) updates.year = input.year;
    if (input.opens_at !== undefined) updates.opens_at = input.opens_at;
    if (input.closes_at !== undefined) updates.closes_at = input.closes_at;
    if (input.status !== undefined) updates.status = input.status;
    if (input.available_programs !== undefined)
      updates.available_programs = input.available_programs;
    if (input.required_documents !== undefined)
      updates.required_documents = input.required_documents;
    if (input.custom_fields !== undefined)
      updates.custom_fields = input.custom_fields;
    if (input.welcome_message !== undefined)
      updates.welcome_message = input.welcome_message;
    if (input.confirmation_message !== undefined)
      updates.confirmation_message = input.confirmation_message;

    if (Object.keys(updates).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("enrollment_periods")
      .update(updates)
      .eq("id", periodId)
      .is("deleted_at", null)
      .select("*")
      .single();

    if (error) {
      if (error.code === "23505") {
        return failure(
          "A period with this name already exists for the given year",
          ErrorCodes.ALREADY_EXISTS,
        );
      }
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentPeriod);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// OPEN ENROLLMENT PERIOD
// ============================================================
// Transitions a period from 'draft' to 'open'. Only drafts can
// be opened. This is the explicit trigger that makes the public
// enrollment form available.

export async function openEnrollmentPeriod(
  periodId: string,
): Promise<ActionResponse<EnrollmentPeriod>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    // Verify current status is draft
    const { data: current, error: fetchError } = await supabase
      .from("enrollment_periods")
      .select("status")
      .eq("id", periodId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Enrollment period not found", ErrorCodes.NOT_FOUND);
    }

    if (current.status !== "draft") {
      return failure(
        `Cannot open a period with status "${current.status}". Only draft periods can be opened.`,
        ErrorCodes.INVALID_STATUS_TRANSITION,
      );
    }

    const { data, error } = await supabase
      .from("enrollment_periods")
      .update({ status: "open" })
      .eq("id", periodId)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentPeriod);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to open enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CLOSE ENROLLMENT PERIOD
// ============================================================
// Transitions from 'open' to 'closed'. Stops accepting new
// applications but existing ones can still be reviewed.

export async function closeEnrollmentPeriod(
  periodId: string,
): Promise<ActionResponse<EnrollmentPeriod>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    const { data: current, error: fetchError } = await supabase
      .from("enrollment_periods")
      .select("status")
      .eq("id", periodId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Enrollment period not found", ErrorCodes.NOT_FOUND);
    }

    if (current.status !== "open") {
      return failure(
        `Cannot close a period with status "${current.status}". Only open periods can be closed.`,
        ErrorCodes.INVALID_STATUS_TRANSITION,
      );
    }

    const { data, error } = await supabase
      .from("enrollment_periods")
      .update({ status: "closed" })
      .eq("id", periodId)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentPeriod);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to close enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// ARCHIVE ENROLLMENT PERIOD
// ============================================================
// Moves a closed period to 'archived'. Archived periods are
// hidden from the default list but preserved for historical data.

export async function archiveEnrollmentPeriod(
  periodId: string,
): Promise<ActionResponse<EnrollmentPeriod>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    const { data: current, error: fetchError } = await supabase
      .from("enrollment_periods")
      .select("status")
      .eq("id", periodId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Enrollment period not found", ErrorCodes.NOT_FOUND);
    }

    if (current.status !== "closed") {
      return failure(
        `Cannot archive a period with status "${current.status}". Only closed periods can be archived.`,
        ErrorCodes.INVALID_STATUS_TRANSITION,
      );
    }

    const { data, error } = await supabase
      .from("enrollment_periods")
      .update({ status: "archived" })
      .eq("id", periodId)
      .select("*")
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as EnrollmentPeriod);
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Failed to archive enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// SOFT DELETE ENROLLMENT PERIOD
// ============================================================
// Only draft periods with zero applications can be deleted.
// Periods with applications should be archived, not deleted.

export async function deleteEnrollmentPeriod(
  periodId: string,
): Promise<ActionResponse<{ id: string }>> {
  try {
    await requirePermission(Permissions.MANAGE_ENROLLMENT_PERIODS);
    const supabase = await createSupabaseServerClient();

    // Check for existing applications
    const { data: current, error: fetchError } = await supabase
      .from("enrollment_periods")
      .select(
        `
        status,
        enrollment_applications(id)
      `,
      )
      .eq("id", periodId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !current) {
      return failure("Enrollment period not found", ErrorCodes.NOT_FOUND);
    }

    const appCount =
      (current.enrollment_applications as Array<{ id: string }>)?.length ?? 0;
    if (appCount > 0) {
      return failure(
        `Cannot delete a period with ${appCount} application(s). Archive it instead.`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    if (current.status !== "draft") {
      return failure(
        "Only draft periods with no applications can be deleted.",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { error } = await supabase
      .from("enrollment_periods")
      .update({ deleted_at: new Date().toISOString() })
      .eq("id", periodId);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ id: periodId });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete enrollment period";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\programs\programs.ts =====

// src/lib/actions/programs/programs.ts
//
// ============================================================
// WattleOS V2 — Module 11: Program & Session Server Actions
// ============================================================
// Manages the full lifecycle of extended-day, OSHC, and
// extracurricular programs. Programs define the template
// (schedule, pricing, capacity); sessions are concrete
// bookable instances generated from those patterns.
//
// WHY programs own sessions: A program is the config, a
// session is a specific date. Sessions are pre-generated
// so parents can browse availability weeks in advance and
// staff can override individual dates (e.g., cancel for a
// public holiday).
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  ActionResponse,
  ErrorCodes,
  failure,
  paginated,
  paginatedFailure,
  PaginatedResponse,
  success,
} from "@/types/api";
import type { User } from "@/types/domain";

// ============================================================
// Types
// ============================================================

export type ProgramType =
  | "before_school_care"
  | "after_school_care"
  | "vacation_care"
  | "extracurricular"
  | "extended_day"
  | "adolescent_program"
  | "senior_elective"
  | "other";

export type BillingType = "per_session" | "per_term" | "per_year" | "included";

export type DayOfWeek =
  | "monday"
  | "tuesday"
  | "wednesday"
  | "thursday"
  | "friday"
  | "saturday"
  | "sunday";

export type SessionStatus =
  | "scheduled"
  | "in_progress"
  | "completed"
  | "cancelled";

export interface Program {
  id: string;
  tenant_id: string;
  name: string;
  code: string | null;
  program_type: ProgramType;
  description: string | null;
  min_age_months: number | null;
  max_age_months: number | null;
  eligible_class_ids: string[] | null;
  default_start_time: string | null;
  default_end_time: string | null;
  default_days: DayOfWeek[];
  max_capacity: number | null;
  session_fee_cents: number;
  casual_fee_cents: number | null;
  billing_type: BillingType;
  cancellation_notice_hours: number;
  late_cancel_fee_cents: number;
  ccs_eligible: boolean;
  ccs_activity_type: string | null;
  ccs_service_id: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface ProgramWithStats extends Program {
  upcoming_session_count: number;
  total_bookings_this_week: number;
}

export interface ProgramSession {
  id: string;
  tenant_id: string;
  program_id: string;
  date: string;
  start_time: string;
  end_time: string;
  max_capacity: number | null;
  status: SessionStatus;
  location: string | null;
  staff_id: string | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface ProgramSessionWithDetails extends ProgramSession {
  program: Pick<
    Program,
    "id" | "name" | "code" | "program_type" | "max_capacity"
  >;
  staff: Pick<User, "id" | "first_name" | "last_name"> | null;
  confirmed_count: number;
  waitlisted_count: number;
  checked_in_count: number;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateProgramInput {
  name: string;
  code?: string | null;
  program_type: ProgramType;
  description?: string | null;
  min_age_months?: number | null;
  max_age_months?: number | null;
  eligible_class_ids?: string[] | null;
  default_start_time?: string | null;
  default_end_time?: string | null;
  default_days?: DayOfWeek[];
  max_capacity?: number | null;
  session_fee_cents?: number;
  casual_fee_cents?: number | null;
  billing_type?: BillingType;
  cancellation_notice_hours?: number;
  late_cancel_fee_cents?: number;
  ccs_eligible?: boolean;
  ccs_activity_type?: string | null;
  ccs_service_id?: string | null;
}

export interface UpdateProgramInput {
  name?: string;
  code?: string | null;
  program_type?: ProgramType;
  description?: string | null;
  min_age_months?: number | null;
  max_age_months?: number | null;
  eligible_class_ids?: string[] | null;
  default_start_time?: string | null;
  default_end_time?: string | null;
  default_days?: DayOfWeek[];
  max_capacity?: number | null;
  session_fee_cents?: number;
  casual_fee_cents?: number | null;
  billing_type?: BillingType;
  cancellation_notice_hours?: number;
  late_cancel_fee_cents?: number;
  ccs_eligible?: boolean;
  ccs_activity_type?: string | null;
  ccs_service_id?: string | null;
  is_active?: boolean;
}

export interface CreateSessionInput {
  program_id: string;
  date: string;
  start_time: string;
  end_time: string;
  max_capacity?: number | null;
  location?: string | null;
  staff_id?: string | null;
  notes?: string | null;
}

export interface UpdateSessionInput {
  start_time?: string;
  end_time?: string;
  max_capacity?: number | null;
  status?: SessionStatus;
  location?: string | null;
  staff_id?: string | null;
  notes?: string | null;
}

export interface ListProgramsParams {
  program_type?: ProgramType;
  is_active?: boolean;
  page?: number;
  per_page?: number;
}

export interface ListSessionsParams {
  program_id?: string;
  from_date?: string;
  to_date?: string;
  status?: SessionStatus;
  staff_id?: string;
  page?: number;
  per_page?: number;
}

// ============================================================
// CREATE PROGRAM
// ============================================================
// Permission: MANAGE_PROGRAMS
// ============================================================

export async function createProgram(
  input: CreateProgramInput,
): Promise<ActionResponse<Program>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    if (!input.name.trim()) {
      return failure("Program name is required", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("programs")
      .insert({
        tenant_id: context.tenant.id,
        name: input.name.trim(),
        code: input.code?.trim() ?? null,
        program_type: input.program_type,
        description: input.description?.trim() ?? null,
        min_age_months: input.min_age_months ?? null,
        max_age_months: input.max_age_months ?? null,
        eligible_class_ids: input.eligible_class_ids ?? null,
        default_start_time: input.default_start_time ?? null,
        default_end_time: input.default_end_time ?? null,
        default_days: input.default_days ?? [],
        max_capacity: input.max_capacity ?? null,
        session_fee_cents: input.session_fee_cents ?? 0,
        casual_fee_cents: input.casual_fee_cents ?? null,
        billing_type: input.billing_type ?? "per_session",
        cancellation_notice_hours: input.cancellation_notice_hours ?? 24,
        late_cancel_fee_cents: input.late_cancel_fee_cents ?? 0,
        ccs_eligible: input.ccs_eligible ?? false,
        ccs_activity_type: input.ccs_activity_type ?? null,
        ccs_service_id: input.ccs_service_id ?? null,
        is_active: true,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as Program);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create program";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE PROGRAM
// ============================================================

export async function updateProgram(
  programId: string,
  input: UpdateProgramInput,
): Promise<ActionResponse<Program>> {
  try {
    await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.name !== undefined) updateData.name = input.name.trim();
    if (input.code !== undefined) updateData.code = input.code?.trim() ?? null;
    if (input.program_type !== undefined)
      updateData.program_type = input.program_type;
    if (input.description !== undefined)
      updateData.description = input.description?.trim() ?? null;
    if (input.min_age_months !== undefined)
      updateData.min_age_months = input.min_age_months;
    if (input.max_age_months !== undefined)
      updateData.max_age_months = input.max_age_months;
    if (input.eligible_class_ids !== undefined)
      updateData.eligible_class_ids = input.eligible_class_ids;
    if (input.default_start_time !== undefined)
      updateData.default_start_time = input.default_start_time;
    if (input.default_end_time !== undefined)
      updateData.default_end_time = input.default_end_time;
    if (input.default_days !== undefined)
      updateData.default_days = input.default_days;
    if (input.max_capacity !== undefined)
      updateData.max_capacity = input.max_capacity;
    if (input.session_fee_cents !== undefined)
      updateData.session_fee_cents = input.session_fee_cents;
    if (input.casual_fee_cents !== undefined)
      updateData.casual_fee_cents = input.casual_fee_cents;
    if (input.billing_type !== undefined)
      updateData.billing_type = input.billing_type;
    if (input.cancellation_notice_hours !== undefined)
      updateData.cancellation_notice_hours = input.cancellation_notice_hours;
    if (input.late_cancel_fee_cents !== undefined)
      updateData.late_cancel_fee_cents = input.late_cancel_fee_cents;
    if (input.ccs_eligible !== undefined)
      updateData.ccs_eligible = input.ccs_eligible;
    if (input.ccs_activity_type !== undefined)
      updateData.ccs_activity_type = input.ccs_activity_type;
    if (input.ccs_service_id !== undefined)
      updateData.ccs_service_id = input.ccs_service_id;
    if (input.is_active !== undefined) updateData.is_active = input.is_active;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("programs")
      .update(updateData)
      .eq("id", programId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as Program);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update program";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// DELETE PROGRAM (soft delete)
// ============================================================

export async function deleteProgram(
  programId: string,
): Promise<ActionResponse<{ deleted: boolean }>> {
  try {
    await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("programs")
      .update({ deleted_at: new Date().toISOString(), is_active: false })
      .eq("id", programId)
      .is("deleted_at", null);

    if (error) {
      return failure(error.message, ErrorCodes.DELETE_FAILED);
    }

    return success({ deleted: true });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to delete program";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST PROGRAMS (Staff view — paginated)
// ============================================================
// Permission: MANAGE_PROGRAMS
// ============================================================

export async function listPrograms(
  params: ListProgramsParams = {},
): Promise<PaginatedResponse<ProgramWithStats>> {
  try {
    await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 25;
    const offset = (page - 1) * perPage;

    // Count
    let countQuery = supabase
      .from("programs")
      .select("id", { count: "exact", head: true })
      .is("deleted_at", null);

    if (params.program_type)
      countQuery = countQuery.eq("program_type", params.program_type);
    if (params.is_active !== undefined)
      countQuery = countQuery.eq("is_active", params.is_active);

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    let query = supabase
      .from("programs")
      .select("*")
      .is("deleted_at", null)
      .order("name", { ascending: true })
      .range(offset, offset + perPage - 1);

    if (params.program_type)
      query = query.eq("program_type", params.program_type);
    if (params.is_active !== undefined)
      query = query.eq("is_active", params.is_active);

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Enrich with stats
    const today = new Date().toISOString().split("T")[0];
    const weekEnd = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
      .toISOString()
      .split("T")[0];

    const programs: ProgramWithStats[] = [];

    for (const row of (data ?? []) as Program[]) {
      // Upcoming session count
      const { count: sessionCount } = await supabase
        .from("program_sessions")
        .select("id", { count: "exact", head: true })
        .eq("program_id", row.id)
        .gte("date", today)
        .neq("status", "cancelled")
        .is("deleted_at", null);

      // Bookings this week
      const { data: weekSessions } = await supabase
        .from("program_sessions")
        .select("id")
        .eq("program_id", row.id)
        .gte("date", today)
        .lte("date", weekEnd)
        .is("deleted_at", null);

      let weekBookings = 0;
      if (weekSessions && weekSessions.length > 0) {
        const sessionIds = (weekSessions as Array<{ id: string }>).map(
          (s) => s.id,
        );
        const { count: bookingCount } = await supabase
          .from("session_bookings")
          .select("id", { count: "exact", head: true })
          .in("session_id", sessionIds)
          .eq("status", "confirmed")
          .is("deleted_at", null);

        weekBookings = bookingCount ?? 0;
      }

      programs.push({
        ...row,
        upcoming_session_count: sessionCount ?? 0,
        total_bookings_this_week: weekBookings,
      });
    }

    return paginated(programs, total, page, perPage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list programs";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SINGLE PROGRAM
// ============================================================

export async function getProgram(
  programId: string,
): Promise<ActionResponse<Program>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("programs")
      .select("*")
      .eq("id", programId)
      .is("deleted_at", null)
      .single();

    if (error) {
      return failure("Program not found", ErrorCodes.NOT_FOUND);
    }

    return success(data as Program);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get program";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST ACTIVE PROGRAMS (Parent view)
// ============================================================
// No special permission — any authenticated tenant member
// can browse active programs.
// ============================================================

export async function listActivePrograms(): Promise<ActionResponse<Program[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("programs")
      .select("*")
      .eq("is_active", true)
      .is("deleted_at", null)
      .order("program_type", { ascending: true })
      .order("name", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as Program[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list programs";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// SESSION MANAGEMENT
// ============================================================

// ============================================================
// CREATE SESSION (manual)
// ============================================================
// Permission: MANAGE_PROGRAMS
// Creates a single session for a specific date. Used for
// one-off sessions or overriding generated patterns.
// ============================================================

export async function createSession(
  input: CreateSessionInput,
): Promise<ActionResponse<ProgramSession>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    if (!input.date) {
      return failure("Session date is required", ErrorCodes.VALIDATION_ERROR);
    }
    if (!input.start_time || !input.end_time) {
      return failure(
        "Start and end times are required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("program_sessions")
      .insert({
        tenant_id: context.tenant.id,
        program_id: input.program_id,
        date: input.date,
        start_time: input.start_time,
        end_time: input.end_time,
        max_capacity: input.max_capacity ?? null,
        status: "scheduled" as SessionStatus,
        location: input.location?.trim() ?? null,
        staff_id: input.staff_id ?? null,
        notes: input.notes?.trim() ?? null,
      })
      .select()
      .single();

    if (error) {
      if (error.code === "23505") {
        return failure(
          "A session already exists for this program on this date",
          ErrorCodes.ALREADY_EXISTS,
        );
      }
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as ProgramSession);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create session";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GENERATE SESSIONS (bulk)
// ============================================================
// Permission: MANAGE_PROGRAMS
// Generates sessions for a program based on its default_days
// pattern for the next N weeks. Skips dates where a session
// already exists.
//
// WHY server action not cron: This gives admins explicit
// control. A cron job can call this same function on a
// schedule via an Edge Function wrapper.
// ============================================================

export async function generateSessions(
  programId: string,
  weeksAhead: number = 4,
): Promise<ActionResponse<{ created: number; skipped: number }>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    // Fetch program
    const { data: program, error: pgError } = await supabase
      .from("programs")
      .select("*")
      .eq("id", programId)
      .is("deleted_at", null)
      .single();

    if (pgError || !program) {
      return failure("Program not found", ErrorCodes.NOT_FOUND);
    }

    const pg = program as Program;

    if (!pg.default_start_time || !pg.default_end_time) {
      return failure(
        "Program must have default start/end times to generate sessions",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    if (pg.default_days.length === 0) {
      return failure(
        "Program must have at least one default day to generate sessions",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const dayMap: Record<DayOfWeek, number> = {
      sunday: 0,
      monday: 1,
      tuesday: 2,
      wednesday: 3,
      thursday: 4,
      friday: 5,
      saturday: 6,
    };

    const targetDayNumbers = pg.default_days.map((d) => dayMap[d]);

    // Get existing session dates to avoid duplicates
    const startDate = new Date();
    const endDate = new Date(Date.now() + weeksAhead * 7 * 24 * 60 * 60 * 1000);

    const { data: existingSessions } = await supabase
      .from("program_sessions")
      .select("date")
      .eq("program_id", programId)
      .gte("date", startDate.toISOString().split("T")[0])
      .lte("date", endDate.toISOString().split("T")[0])
      .is("deleted_at", null);

    const existingDates = new Set(
      (existingSessions ?? []).map((s) => (s as { date: string }).date),
    );

    // Generate date list
    const sessionsToCreate: Array<{
      tenant_id: string;
      program_id: string;
      date: string;
      start_time: string;
      end_time: string;
      status: SessionStatus;
    }> = [];

    const cursor = new Date(startDate);
    cursor.setHours(0, 0, 0, 0);

    while (cursor <= endDate) {
      if (targetDayNumbers.includes(cursor.getDay())) {
        const dateStr = cursor.toISOString().split("T")[0];
        if (!existingDates.has(dateStr)) {
          sessionsToCreate.push({
            tenant_id: context.tenant.id,
            program_id: programId,
            date: dateStr,
            start_time: pg.default_start_time!,
            end_time: pg.default_end_time!,
            status: "scheduled",
          });
        }
      }
      cursor.setDate(cursor.getDate() + 1);
    }

    let created = 0;
    if (sessionsToCreate.length > 0) {
      const { data: inserted, error: insertError } = await supabase
        .from("program_sessions")
        .insert(sessionsToCreate)
        .select("id");

      if (insertError) {
        return failure(insertError.message, ErrorCodes.CREATE_FAILED);
      }

      created = inserted?.length ?? 0;
    }

    return success({
      created,
      skipped: existingDates.size,
    });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to generate sessions";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE SESSION
// ============================================================

export async function updateSession(
  sessionId: string,
  input: UpdateSessionInput,
): Promise<ActionResponse<ProgramSession>> {
  try {
    await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.start_time !== undefined)
      updateData.start_time = input.start_time;
    if (input.end_time !== undefined) updateData.end_time = input.end_time;
    if (input.max_capacity !== undefined)
      updateData.max_capacity = input.max_capacity;
    if (input.status !== undefined) updateData.status = input.status;
    if (input.location !== undefined)
      updateData.location = input.location?.trim() ?? null;
    if (input.staff_id !== undefined) updateData.staff_id = input.staff_id;
    if (input.notes !== undefined)
      updateData.notes = input.notes?.trim() ?? null;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("program_sessions")
      .update(updateData)
      .eq("id", sessionId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as ProgramSession);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update session";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CANCEL SESSION
// ============================================================
// Cancels a session and all confirmed bookings within it.
// Cancelled bookings are marked as 'cancelled' with a system
// reason. Waitlisted bookings are also cancelled.
// ============================================================

export async function cancelSession(
  sessionId: string,
  reason?: string,
): Promise<ActionResponse<{ cancelled_bookings: number }>> {
  try {
    await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    // Cancel the session
    const { error: sessionError } = await supabase
      .from("program_sessions")
      .update({ status: "cancelled" as SessionStatus })
      .eq("id", sessionId)
      .is("deleted_at", null);

    if (sessionError) {
      return failure(sessionError.message, ErrorCodes.UPDATE_FAILED);
    }

    // Cancel all non-cancelled bookings for this session
    const { data: affectedBookings, error: bookingError } = await supabase
      .from("session_bookings")
      .update({
        status: "cancelled",
        cancelled_at: new Date().toISOString(),
        cancellation_reason: reason?.trim() ?? "Session cancelled by staff",
      })
      .eq("session_id", sessionId)
      .in("status", ["confirmed", "waitlisted"])
      .is("deleted_at", null)
      .select("id");

    if (bookingError) {
      return failure(bookingError.message, ErrorCodes.UPDATE_FAILED);
    }

    return success({ cancelled_bookings: affectedBookings?.length ?? 0 });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to cancel session";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST SESSIONS (Staff calendar view — paginated)
// ============================================================
// Permission: MANAGE_PROGRAMS or CHECKIN_CHECKOUT
// Returns sessions with booking counts for calendar display.
// ============================================================

export async function listSessions(
  params: ListSessionsParams = {},
): Promise<PaginatedResponse<ProgramSessionWithDetails>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const page = params.page ?? 1;
    const perPage = params.per_page ?? 50;
    const offset = (page - 1) * perPage;

    // Count
    let countQuery = supabase
      .from("program_sessions")
      .select("id", { count: "exact", head: true })
      .is("deleted_at", null);

    if (params.program_id)
      countQuery = countQuery.eq("program_id", params.program_id);
    if (params.from_date) countQuery = countQuery.gte("date", params.from_date);
    if (params.to_date) countQuery = countQuery.lte("date", params.to_date);
    if (params.status) countQuery = countQuery.eq("status", params.status);
    if (params.staff_id)
      countQuery = countQuery.eq("staff_id", params.staff_id);

    const { count, error: countError } = await countQuery;

    if (countError) {
      return paginatedFailure(countError.message, ErrorCodes.DATABASE_ERROR);
    }

    const total = count ?? 0;
    if (total === 0) {
      return paginated([], 0, page, perPage);
    }

    // Data
    let query = supabase
      .from("program_sessions")
      .select(
        `
        *,
        program:programs!program_sessions_program_id_fkey(id, name, code, program_type, max_capacity),
        staff:users!program_sessions_staff_id_fkey(id, first_name, last_name),
        session_bookings(id, status, checked_in_at)
      `,
      )
      .is("deleted_at", null)
      .order("date", { ascending: true })
      .order("start_time", { ascending: true })
      .range(offset, offset + perPage - 1);

    if (params.program_id) query = query.eq("program_id", params.program_id);
    if (params.from_date) query = query.gte("date", params.from_date);
    if (params.to_date) query = query.lte("date", params.to_date);
    if (params.status) query = query.eq("status", params.status);
    if (params.staff_id) query = query.eq("staff_id", params.staff_id);

    const { data, error } = await query;

    if (error) {
      return paginatedFailure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    const sessions: ProgramSessionWithDetails[] = (
      (data ?? []) as Array<Record<string, unknown>>
    ).map((row) => {
      const bookings = (row.session_bookings ?? []) as Array<{
        id: string;
        status: string;
        checked_in_at: string | null;
      }>;

      const activeBookings = bookings.filter(
        (b) => b.status !== "cancelled" && b.status !== "no_show",
      );

      return {
        id: row.id as string,
        tenant_id: row.tenant_id as string,
        program_id: row.program_id as string,
        date: row.date as string,
        start_time: row.start_time as string,
        end_time: row.end_time as string,
        max_capacity: row.max_capacity as number | null,
        status: row.status as SessionStatus,
        location: row.location as string | null,
        staff_id: row.staff_id as string | null,
        notes: row.notes as string | null,
        created_at: row.created_at as string,
        updated_at: row.updated_at as string,
        deleted_at: row.deleted_at as string | null,
        program: row.program as Pick<
          Program,
          "id" | "name" | "code" | "program_type" | "max_capacity"
        >,
        staff: row.staff as Pick<
          User,
          "id" | "first_name" | "last_name"
        > | null,
        confirmed_count: activeBookings.filter((b) => b.status === "confirmed")
          .length,
        waitlisted_count: activeBookings.filter(
          (b) => b.status === "waitlisted",
        ).length,
        checked_in_count: activeBookings.filter((b) => b.checked_in_at !== null)
          .length,
      };
    });

    return paginated(sessions, total, page, perPage);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to list sessions";
    return paginatedFailure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SESSION DETAIL
// ============================================================

export async function getSession(
  sessionId: string,
): Promise<ActionResponse<ProgramSessionWithDetails>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("program_sessions")
      .select(
        `
        *,
        program:programs!program_sessions_program_id_fkey(id, name, code, program_type, max_capacity),
        staff:users!program_sessions_staff_id_fkey(id, first_name, last_name),
        session_bookings(id, status, checked_in_at)
      `,
      )
      .eq("id", sessionId)
      .is("deleted_at", null)
      .single();

    if (error) {
      return failure("Session not found", ErrorCodes.NOT_FOUND);
    }

    const row = data as Record<string, unknown>;
    const bookings = (row.session_bookings ?? []) as Array<{
      id: string;
      status: string;
      checked_in_at: string | null;
    }>;

    const activeBookings = bookings.filter(
      (b) => b.status !== "cancelled" && b.status !== "no_show",
    );

    const session: ProgramSessionWithDetails = {
      id: row.id as string,
      tenant_id: row.tenant_id as string,
      program_id: row.program_id as string,
      date: row.date as string,
      start_time: row.start_time as string,
      end_time: row.end_time as string,
      max_capacity: row.max_capacity as number | null,
      status: row.status as SessionStatus,
      location: row.location as string | null,
      staff_id: row.staff_id as string | null,
      notes: row.notes as string | null,
      created_at: row.created_at as string,
      updated_at: row.updated_at as string,
      deleted_at: row.deleted_at as string | null,
      program: row.program as Pick<
        Program,
        "id" | "name" | "code" | "program_type" | "max_capacity"
      >,
      staff: row.staff as Pick<User, "id" | "first_name" | "last_name"> | null,
      confirmed_count: activeBookings.filter((b) => b.status === "confirmed")
        .length,
      waitlisted_count: activeBookings.filter((b) => b.status === "waitlisted")
        .length,
      checked_in_count: activeBookings.filter((b) => b.checked_in_at !== null)
        .length,
    };

    return success(session);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get session";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET PROGRAM UTILIZATION REPORT
// ============================================================
// Permission: VIEW_PROGRAM_REPORTS
// Returns capacity vs. actual attendance for a date range.
// ============================================================

export interface UtilizationReportRow {
  program_id: string;
  program_name: string;
  program_type: ProgramType;
  total_sessions: number;
  total_capacity: number;
  total_bookings: number;
  total_checked_in: number;
  utilization_pct: number;
  attendance_pct: number;
}

export async function getProgramUtilization(
  fromDate: string,
  toDate: string,
): Promise<ActionResponse<UtilizationReportRow[]>> {
  try {
    await requirePermission(Permissions.VIEW_PROGRAM_REPORTS);
    const supabase = await createSupabaseServerClient();

    // Get all programs
    const { data: programs } = await supabase
      .from("programs")
      .select("id, name, program_type, max_capacity")
      .is("deleted_at", null)
      .order("name", { ascending: true });

    if (!programs || programs.length === 0) {
      return success([]);
    }

    const report: UtilizationReportRow[] = [];

    for (const pg of programs as Array<{
      id: string;
      name: string;
      program_type: ProgramType;
      max_capacity: number | null;
    }>) {
      // Sessions in range
      const { data: sessions } = await supabase
        .from("program_sessions")
        .select("id, max_capacity")
        .eq("program_id", pg.id)
        .gte("date", fromDate)
        .lte("date", toDate)
        .neq("status", "cancelled")
        .is("deleted_at", null);

      if (!sessions || sessions.length === 0) continue;

      const sessionIds = (sessions as Array<{ id: string }>).map((s) => s.id);
      const totalCapacity = (
        sessions as Array<{ id: string; max_capacity: number | null }>
      ).reduce((sum, s) => sum + (s.max_capacity ?? pg.max_capacity ?? 0), 0);

      // Bookings for those sessions
      const { data: bookings } = await supabase
        .from("session_bookings")
        .select("id, status, checked_in_at")
        .in("session_id", sessionIds)
        .is("deleted_at", null);

      const confirmed = (bookings ?? []).filter(
        (b) => (b as { status: string }).status === "confirmed",
      ).length;
      const checkedIn = (bookings ?? []).filter(
        (b) => (b as { checked_in_at: string | null }).checked_in_at !== null,
      ).length;

      report.push({
        program_id: pg.id,
        program_name: pg.name,
        program_type: pg.program_type,
        total_sessions: sessions.length,
        total_capacity: totalCapacity,
        total_bookings: confirmed,
        total_checked_in: checkedIn,
        utilization_pct:
          totalCapacity > 0 ? Math.round((confirmed / totalCapacity) * 100) : 0,
        attendance_pct:
          confirmed > 0 ? Math.round((checkedIn / confirmed) * 100) : 0,
      });
    }

    return success(report);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get utilization report";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\programs\recurring-patterns.ts =====

// src/lib/actions/programs/recurring-patterns.ts
//
// ============================================================
// WattleOS V2 — Module 11: Recurring Booking Pattern Actions
// ============================================================
// Manages recurring booking patterns — the "every Tuesday and
// Thursday OSHC" rule that parents set up. When sessions are
// generated (via generateSessions), these patterns are applied
// to auto-create bookings.
//
// WHY patterns separate from bookings: A pattern is the rule
// ("every Tuesday"); a booking is the instance ("Tuesday 25th
// Feb"). Separating them lets parents pause/cancel the pattern
// without touching individual bookings, and lets the session
// generator apply patterns idempotently.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type { Student, User } from "@/types/domain";
import type { DayOfWeek, Program } from "./programs";

// ============================================================
// Types
// ============================================================

export type RecurringPatternStatus = "active" | "paused" | "cancelled";

export interface RecurringBookingPattern {
  id: string;
  tenant_id: string;
  program_id: string;
  student_id: string;
  booked_by: string;
  days_of_week: DayOfWeek[];
  effective_from: string;
  effective_until: string | null;
  status: RecurringPatternStatus;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface RecurringPatternWithDetails extends RecurringBookingPattern {
  program: Pick<
    Program,
    "id" | "name" | "code" | "program_type" | "session_fee_cents"
  >;
  student: Pick<Student, "id" | "first_name" | "last_name">;
  booked_by_user: Pick<User, "id" | "first_name" | "last_name">;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateRecurringPatternInput {
  program_id: string;
  student_id: string;
  days_of_week: DayOfWeek[];
  effective_from: string;
  effective_until?: string | null;
}

export interface UpdateRecurringPatternInput {
  days_of_week?: DayOfWeek[];
  effective_until?: string | null;
  status?: RecurringPatternStatus;
}

// ============================================================
// CREATE RECURRING PATTERN
// ============================================================
// Can be created by parent (RLS is_guardian_of) or staff
// (MANAGE_BOOKINGS). Validates that the requested days match
// the program's default_days.
// ============================================================

export async function createRecurringPattern(
  input: CreateRecurringPatternInput,
): Promise<ActionResponse<RecurringBookingPattern>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    if (input.days_of_week.length === 0) {
      return failure(
        "At least one day of the week is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (!input.effective_from) {
      return failure(
        "Effective from date is required",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Validate program exists and requested days are within program's schedule
    const { data: program, error: pgError } = await supabase
      .from("programs")
      .select("id, default_days, is_active")
      .eq("id", input.program_id)
      .is("deleted_at", null)
      .single();

    if (pgError || !program) {
      return failure("Program not found", ErrorCodes.NOT_FOUND);
    }

    const pg = program as {
      id: string;
      default_days: DayOfWeek[];
      is_active: boolean;
    };

    if (!pg.is_active) {
      return failure(
        "This program is not currently active",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check that requested days are within program's schedule
    const invalidDays = input.days_of_week.filter(
      (d) => !pg.default_days.includes(d),
    );
    if (invalidDays.length > 0) {
      return failure(
        `This program does not run on: ${invalidDays.join(", ")}. Available days: ${pg.default_days.join(", ")}`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check for existing active pattern for this student + program
    const { data: existing } = await supabase
      .from("recurring_booking_patterns")
      .select("id, status")
      .eq("program_id", input.program_id)
      .eq("student_id", input.student_id)
      .eq("status", "active")
      .is("deleted_at", null)
      .limit(1);

    if (existing && existing.length > 0) {
      return failure(
        "An active recurring pattern already exists for this student and program. Update or cancel the existing pattern first.",
        ErrorCodes.ALREADY_EXISTS,
      );
    }

    const { data, error } = await supabase
      .from("recurring_booking_patterns")
      .insert({
        tenant_id: context.tenant.id,
        program_id: input.program_id,
        student_id: input.student_id,
        booked_by: context.user.id,
        days_of_week: input.days_of_week,
        effective_from: input.effective_from,
        effective_until: input.effective_until ?? null,
        status: "active" as RecurringPatternStatus,
      })
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as RecurringBookingPattern);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create recurring pattern";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE RECURRING PATTERN
// ============================================================
// Updates days, end date, or status. Changing days only
// affects future session generation — existing bookings
// are not modified.
// ============================================================

export async function updateRecurringPattern(
  patternId: string,
  input: UpdateRecurringPatternInput,
): Promise<ActionResponse<RecurringBookingPattern>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {};
    if (input.days_of_week !== undefined) {
      if (input.days_of_week.length === 0) {
        return failure(
          "At least one day is required",
          ErrorCodes.VALIDATION_ERROR,
        );
      }
      updateData.days_of_week = input.days_of_week;
    }
    if (input.effective_until !== undefined)
      updateData.effective_until = input.effective_until;
    if (input.status !== undefined) updateData.status = input.status;

    if (Object.keys(updateData).length === 0) {
      return failure("No fields to update", ErrorCodes.VALIDATION_ERROR);
    }

    const { data, error } = await supabase
      .from("recurring_booking_patterns")
      .update(updateData)
      .eq("id", patternId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as RecurringBookingPattern);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update pattern";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// PAUSE RECURRING PATTERN
// ============================================================
// Convenience action: sets status to 'paused'. Future
// session generation will skip this pattern. Existing
// bookings remain untouched.
// ============================================================

export async function pauseRecurringPattern(
  patternId: string,
): Promise<ActionResponse<RecurringBookingPattern>> {
  return updateRecurringPattern(patternId, { status: "paused" });
}

// ============================================================
// RESUME RECURRING PATTERN
// ============================================================

export async function resumeRecurringPattern(
  patternId: string,
): Promise<ActionResponse<RecurringBookingPattern>> {
  return updateRecurringPattern(patternId, { status: "active" });
}

// ============================================================
// CANCEL RECURRING PATTERN
// ============================================================
// Sets status to 'cancelled' and optionally sets effective_until
// to today. Does NOT cancel existing bookings — those remain
// as individual bookings that can be cancelled separately.
//
// WHY not cascade cancel: A parent might cancel the recurring
// pattern but still want to attend already-booked sessions.
// ============================================================

export async function cancelRecurringPattern(
  patternId: string,
  cancelFutureBookings: boolean = false,
): Promise<ActionResponse<RecurringBookingPattern>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const today = new Date().toISOString().split("T")[0];

    const { data, error } = await supabase
      .from("recurring_booking_patterns")
      .update({
        status: "cancelled" as RecurringPatternStatus,
        effective_until: today,
      })
      .eq("id", patternId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    const pattern = data as RecurringBookingPattern;

    // Optionally cancel future bookings tied to this pattern
    if (cancelFutureBookings) {
      // Find future sessions
      const { data: futureSessions } = await supabase
        .from("program_sessions")
        .select("id")
        .eq("program_id", pattern.program_id)
        .gt("date", today)
        .is("deleted_at", null);

      if (futureSessions && futureSessions.length > 0) {
        const sessionIds = (futureSessions as Array<{ id: string }>).map(
          (s) => s.id,
        );

        await supabase
          .from("session_bookings")
          .update({
            status: "cancelled",
            cancelled_at: new Date().toISOString(),
            cancelled_by: context.user.id,
            cancellation_reason: "Recurring pattern cancelled",
          })
          .eq("recurring_pattern_id", patternId)
          .eq("student_id", pattern.student_id)
          .in("session_id", sessionIds)
          .eq("status", "confirmed")
          .is("deleted_at", null);
      }
    }

    return success(pattern);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to cancel pattern";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST PATTERNS FOR STUDENT
// ============================================================
// Returns all recurring patterns for a student with program
// details. Used in the parent portal "My Bookings" page.
// ============================================================

export async function getStudentPatterns(
  studentId: string,
): Promise<ActionResponse<RecurringPatternWithDetails[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("recurring_booking_patterns")
      .select(
        `
        *,
        program:programs!recurring_booking_patterns_program_id_fkey(id, name, code, program_type, session_fee_cents),
        student:students!recurring_booking_patterns_student_id_fkey(id, first_name, last_name),
        booked_by_user:users!recurring_booking_patterns_booked_by_fkey(id, first_name, last_name)
      `,
      )
      .eq("student_id", studentId)
      .is("deleted_at", null)
      .order("status", { ascending: true })
      .order("created_at", { ascending: false });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as RecurringPatternWithDetails[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get patterns";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// LIST PATTERNS FOR PROGRAM (Staff view)
// ============================================================
// Permission: MANAGE_PROGRAMS
// Returns all active/paused recurring patterns for a program.
// Used in the program detail admin page.
// ============================================================

export async function getProgramPatterns(
  programId: string,
): Promise<ActionResponse<RecurringPatternWithDetails[]>> {
  try {
    await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("recurring_booking_patterns")
      .select(
        `
        *,
        program:programs!recurring_booking_patterns_program_id_fkey(id, name, code, program_type, session_fee_cents),
        student:students!recurring_booking_patterns_student_id_fkey(id, first_name, last_name),
        booked_by_user:users!recurring_booking_patterns_booked_by_fkey(id, first_name, last_name)
      `,
      )
      .eq("program_id", programId)
      .in("status", ["active", "paused"])
      .is("deleted_at", null)
      .order("created_at", { ascending: false });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as RecurringPatternWithDetails[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get patterns";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// APPLY RECURRING PATTERNS TO SESSIONS
// ============================================================
// Permission: MANAGE_PROGRAMS
// For a given program, finds all upcoming sessions and creates
// bookings from active recurring patterns. Idempotent — skips
// sessions where the student already has a booking.
//
// WHY explicit action: This runs after generateSessions to
// fill new sessions with recurring bookings. Can also be
// triggered manually after a new pattern is created to
// back-fill already-generated sessions.
// ============================================================

export async function applyPatternsToSessions(
  programId: string,
): Promise<ActionResponse<{ bookings_created: number; skipped: number }>> {
  try {
    const context = await requirePermission(Permissions.MANAGE_PROGRAMS);
    const supabase = await createSupabaseServerClient();

    const today = new Date().toISOString().split("T")[0];

    // Get active patterns for this program
    const { data: patterns } = await supabase
      .from("recurring_booking_patterns")
      .select("*")
      .eq("program_id", programId)
      .eq("status", "active")
      .is("deleted_at", null);

    if (!patterns || patterns.length === 0) {
      return success({ bookings_created: 0, skipped: 0 });
    }

    // Get upcoming sessions
    const { data: sessions } = await supabase
      .from("program_sessions")
      .select("id, date, program_id")
      .eq("program_id", programId)
      .gte("date", today)
      .eq("status", "scheduled")
      .is("deleted_at", null);

    if (!sessions || sessions.length === 0) {
      return success({ bookings_created: 0, skipped: 0 });
    }

    // Get program for fee info
    const { data: program } = await supabase
      .from("programs")
      .select("session_fee_cents")
      .eq("id", programId)
      .single();

    const feeCents = program
      ? (program as { session_fee_cents: number }).session_fee_cents
      : 0;

    const dayMap: Record<string, DayOfWeek> = {
      "0": "sunday",
      "1": "monday",
      "2": "tuesday",
      "3": "wednesday",
      "4": "thursday",
      "5": "friday",
      "6": "saturday",
    };

    let created = 0;
    let skipped = 0;

    for (const pattern of patterns as RecurringBookingPattern[]) {
      for (const sess of sessions as Array<{
        id: string;
        date: string;
        program_id: string;
      }>) {
        // Check if session date is within pattern's effective range
        if (sess.date < pattern.effective_from) continue;
        if (pattern.effective_until && sess.date > pattern.effective_until)
          continue;

        // Check if session's day of week matches pattern
        const sessionDate = new Date(sess.date + "T00:00:00");
        const sessionDay = dayMap[String(sessionDate.getDay())];
        if (!pattern.days_of_week.includes(sessionDay)) continue;

        // Check if booking already exists
        const { data: existing } = await supabase
          .from("session_bookings")
          .select("id")
          .eq("session_id", sess.id)
          .eq("student_id", pattern.student_id)
          .is("deleted_at", null)
          .limit(1);

        if (existing && existing.length > 0) {
          skipped++;
          continue;
        }

        // Create booking
        const { error: insertError } = await supabase
          .from("session_bookings")
          .insert({
            tenant_id: context.tenant.id,
            session_id: sess.id,
            student_id: pattern.student_id,
            booked_by: pattern.booked_by,
            booking_type: "recurring",
            recurring_pattern_id: pattern.id,
            status: "confirmed",
            fee_cents: feeCents,
            billing_status: "unbilled",
          });

        if (!insertError) {
          created++;
        } else {
          skipped++;
        }
      }
    }

    return success({ bookings_created: created, skipped });
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to apply patterns";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}


===== D:\.code\wattleos\src\lib\actions\programs\session-bookings.ts =====

// src/lib/actions/programs/session-bookings.ts
//
// ============================================================
// WattleOS V2 — Module 11: Session Booking Server Actions
// ============================================================
// Handles the full booking lifecycle: book → confirm/waitlist
// → check-in → check-out → complete. Includes cancellation
// with policy enforcement (late cancellation fees) and
// automatic waitlist promotion when a spot opens.
//
// WHY bookings track check-in/out: For CCS compliance,
// Australian schools must record exact attendance times for
// each funded session. The kiosk view calls checkIn/checkOut
// which timestamps directly on the booking row.
// ============================================================

"use server";

import { getTenantContext, requirePermission } from "@/lib/auth/tenant-context";
import { Permissions } from "@/lib/constants/permissions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ActionResponse, ErrorCodes, failure, success } from "@/types/api";
import type { Student, User } from "@/types/domain";
import type { Program, ProgramSession, SessionStatus } from "./programs";

// ============================================================
// Types
// ============================================================

export type BookingType = "recurring" | "casual" | "makeup";
export type BookingStatus =
  | "confirmed"
  | "waitlisted"
  | "cancelled"
  | "no_show";
export type BillingStatus = "unbilled" | "billed" | "waived" | "refunded";

export interface SessionBooking {
  id: string;
  tenant_id: string;
  session_id: string;
  student_id: string;
  booked_by: string;
  booking_type: BookingType;
  recurring_pattern_id: string | null;
  status: BookingStatus;
  waitlist_position: number | null;
  checked_in_at: string | null;
  checked_in_by: string | null;
  checked_out_at: string | null;
  checked_out_by: string | null;
  fee_cents: number;
  billing_status: BillingStatus;
  invoice_line_id: string | null;
  cancelled_at: string | null;
  cancelled_by: string | null;
  cancellation_reason: string | null;
  late_cancellation: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface SessionBookingWithDetails extends SessionBooking {
  student: Pick<
    Student,
    "id" | "first_name" | "last_name" | "dob" | "photo_url"
  >;
  booked_by_user: Pick<User, "id" | "first_name" | "last_name">;
  session: Pick<
    ProgramSession,
    "id" | "date" | "start_time" | "end_time" | "status"
  > & {
    program: Pick<Program, "id" | "name" | "code" | "program_type">;
  };
}

/** Compact view for kiosk — minimal data, big tap targets */
export interface KioskBookingRow {
  booking_id: string;
  student_id: string;
  student_first_name: string;
  student_last_name: string;
  student_photo_url: string | null;
  checked_in_at: string | null;
  checked_out_at: string | null;
  has_medical_conditions: boolean;
  medical_summary: string | null;
}

// ============================================================
// Input Types
// ============================================================

export interface CreateBookingInput {
  session_id: string;
  student_id: string;
  booking_type?: BookingType;
  recurring_pattern_id?: string | null;
}

export interface CancelBookingInput {
  booking_id: string;
  reason?: string;
}

// ============================================================
// CREATE BOOKING (Parent or Staff)
// ============================================================
// Parents book via RLS (is_guardian_of). Staff book via
// MANAGE_BOOKINGS permission. Automatically waitlists if
// session is at capacity.
//
// WHY fee calculated at booking time: The fee is locked in
// when the booking is created (casual vs recurring rate).
// Changing the program price later doesn't affect existing
// bookings — this matches how real-world OSHC billing works.
// ============================================================

export async function createBooking(
  input: CreateBookingInput,
): Promise<ActionResponse<SessionBooking>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Fetch session + program to determine capacity and pricing
    const { data: session, error: sessError } = await supabase
      .from("program_sessions")
      .select(
        `
        *,
        program:programs!program_sessions_program_id_fkey(
          id, max_capacity, session_fee_cents, casual_fee_cents
        )
      `,
      )
      .eq("id", input.session_id)
      .is("deleted_at", null)
      .single();

    if (sessError || !session) {
      return failure("Session not found", ErrorCodes.NOT_FOUND);
    }

    const sess = session as ProgramSession & {
      program: Pick<
        Program,
        "id" | "max_capacity" | "session_fee_cents" | "casual_fee_cents"
      >;
    };

    if (sess.status === "cancelled") {
      return failure(
        "This session has been cancelled",
        ErrorCodes.VALIDATION_ERROR,
      );
    }
    if (sess.status === "completed") {
      return failure(
        "This session has already completed",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check for duplicate booking
    const { data: existing } = await supabase
      .from("session_bookings")
      .select("id, status")
      .eq("session_id", input.session_id)
      .eq("student_id", input.student_id)
      .is("deleted_at", null)
      .limit(1);

    if (existing && existing.length > 0) {
      const existingStatus = (existing[0] as { status: string }).status;
      if (existingStatus !== "cancelled") {
        return failure(
          "This student already has a booking for this session",
          ErrorCodes.ALREADY_EXISTS,
        );
      }
    }

    // Determine capacity
    const effectiveCapacity =
      sess.max_capacity ?? sess.program.max_capacity ?? null;

    // Count current confirmed bookings
    const { count: confirmedCount } = await supabase
      .from("session_bookings")
      .select("id", { count: "exact", head: true })
      .eq("session_id", input.session_id)
      .eq("status", "confirmed")
      .is("deleted_at", null);

    const isAtCapacity =
      effectiveCapacity !== null && (confirmedCount ?? 0) >= effectiveCapacity;

    // Determine status and waitlist position
    let bookingStatus: BookingStatus = "confirmed";
    let waitlistPosition: number | null = null;

    if (isAtCapacity) {
      bookingStatus = "waitlisted";

      // Get next waitlist position
      const { data: lastWaitlisted } = await supabase
        .from("session_bookings")
        .select("waitlist_position")
        .eq("session_id", input.session_id)
        .eq("status", "waitlisted")
        .is("deleted_at", null)
        .order("waitlist_position", { ascending: false })
        .limit(1);

      const lastPos =
        lastWaitlisted && lastWaitlisted.length > 0
          ? ((lastWaitlisted[0] as { waitlist_position: number | null })
              .waitlist_position ?? 0)
          : 0;

      waitlistPosition = lastPos + 1;
    }

    // Determine fee
    const bookingType = input.booking_type ?? "casual";
    const feeCents =
      bookingType === "casual"
        ? (sess.program.casual_fee_cents ?? sess.program.session_fee_cents)
        : sess.program.session_fee_cents;

    const { data, error } = await supabase
      .from("session_bookings")
      .insert({
        tenant_id: context.tenant.id,
        session_id: input.session_id,
        student_id: input.student_id,
        booked_by: context.user.id,
        booking_type: bookingType,
        recurring_pattern_id: input.recurring_pattern_id ?? null,
        status: bookingStatus,
        waitlist_position: waitlistPosition,
        fee_cents: feeCents,
        billing_status: "unbilled" as BillingStatus,
      })
      .select()
      .single();

    if (error) {
      if (error.code === "23505") {
        return failure(
          "This student already has a booking for this session",
          ErrorCodes.ALREADY_EXISTS,
        );
      }
      return failure(error.message, ErrorCodes.CREATE_FAILED);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to create booking";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CANCEL BOOKING
// ============================================================
// Enforces cancellation policy: if within the notice period,
// marks as late_cancellation (fee may still apply). After
// cancelling, promotes the next waitlisted child.
// ============================================================

export async function cancelBooking(
  input: CancelBookingInput,
): Promise<ActionResponse<SessionBooking>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Fetch booking + session + program for policy check
    const { data: booking, error: bkError } = await supabase
      .from("session_bookings")
      .select(
        `
        *,
        session:program_sessions!session_bookings_session_id_fkey(
          id, date, start_time, status,
          program:programs!program_sessions_program_id_fkey(
            cancellation_notice_hours, late_cancel_fee_cents
          )
        )
      `,
      )
      .eq("id", input.booking_id)
      .is("deleted_at", null)
      .single();

    if (bkError || !booking) {
      return failure("Booking not found", ErrorCodes.NOT_FOUND);
    }

    const bk = booking as SessionBooking & {
      session: {
        id: string;
        date: string;
        start_time: string;
        status: SessionStatus;
        program: {
          cancellation_notice_hours: number;
          late_cancel_fee_cents: number;
        };
      };
    };

    if (bk.status === "cancelled") {
      return failure(
        "Booking is already cancelled",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    // Check if this is a late cancellation
    const sessionStart = new Date(
      `${bk.session.date}T${bk.session.start_time}`,
    );
    const noticeHours = bk.session.program.cancellation_notice_hours;
    const cutoff = new Date(
      sessionStart.getTime() - noticeHours * 60 * 60 * 1000,
    );
    const isLate = new Date() > cutoff;

    const { data, error } = await supabase
      .from("session_bookings")
      .update({
        status: "cancelled" as BookingStatus,
        cancelled_at: new Date().toISOString(),
        cancelled_by: context.user.id,
        cancellation_reason: input.reason?.trim() ?? null,
        late_cancellation: isLate,
      })
      .eq("id", input.booking_id)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    // If the cancelled booking was confirmed, promote next waitlisted
    if (bk.status === "confirmed") {
      await promoteNextWaitlisted(supabase, bk.session_id);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to cancel booking";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// PROMOTE NEXT WAITLISTED (internal helper)
// ============================================================
// Finds the waitlisted booking with the lowest position and
// promotes it to confirmed. Resets waitlist_position to null.
// ============================================================

async function promoteNextWaitlisted(
  supabase: Awaited<ReturnType<typeof createSupabaseServerClient>>,
  sessionId: string,
): Promise<void> {
  const { data: nextWaiting } = await supabase
    .from("session_bookings")
    .select("id")
    .eq("session_id", sessionId)
    .eq("status", "waitlisted")
    .is("deleted_at", null)
    .order("waitlist_position", { ascending: true })
    .limit(1);

  if (nextWaiting && nextWaiting.length > 0) {
    const nextId = (nextWaiting[0] as { id: string }).id;
    await supabase
      .from("session_bookings")
      .update({
        status: "confirmed" as BookingStatus,
        waitlist_position: null,
      })
      .eq("id", nextId);

    // TODO: Send notification to parent that their child has been
    // promoted from waitlist (via Module 12 notification system)
  }
}

// ============================================================
// CHECK IN (Kiosk)
// ============================================================
// Permission: CHECKIN_CHECKOUT
// Records the check-in timestamp and who performed it.
// Designed for iPad kiosk tap — one call per child.
// ============================================================

export async function checkIn(
  bookingId: string,
): Promise<ActionResponse<SessionBooking>> {
  try {
    const context = await requirePermission(Permissions.CHECKIN_CHECKOUT);
    const supabase = await createSupabaseServerClient();

    // Verify booking exists and is confirmed
    const { data: existing, error: fetchError } = await supabase
      .from("session_bookings")
      .select("id, status, checked_in_at")
      .eq("id", bookingId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !existing) {
      return failure("Booking not found", ErrorCodes.NOT_FOUND);
    }

    const bk = existing as {
      id: string;
      status: string;
      checked_in_at: string | null;
    };

    if (bk.status !== "confirmed") {
      return failure(
        `Cannot check in a ${bk.status} booking`,
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    if (bk.checked_in_at) {
      return failure(
        "Child is already checked in",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("session_bookings")
      .update({
        checked_in_at: new Date().toISOString(),
        checked_in_by: context.user.id,
      })
      .eq("id", bookingId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to check in";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// CHECK OUT (Kiosk)
// ============================================================
// Permission: CHECKIN_CHECKOUT
// Records the check-out timestamp. Must be after check-in.
// ============================================================

export async function checkOut(
  bookingId: string,
): Promise<ActionResponse<SessionBooking>> {
  try {
    const context = await requirePermission(Permissions.CHECKIN_CHECKOUT);
    const supabase = await createSupabaseServerClient();

    // Verify booking is checked in
    const { data: existing, error: fetchError } = await supabase
      .from("session_bookings")
      .select("id, checked_in_at, checked_out_at")
      .eq("id", bookingId)
      .is("deleted_at", null)
      .single();

    if (fetchError || !existing) {
      return failure("Booking not found", ErrorCodes.NOT_FOUND);
    }

    const bk = existing as {
      id: string;
      checked_in_at: string | null;
      checked_out_at: string | null;
    };

    if (!bk.checked_in_at) {
      return failure(
        "Child must be checked in before checking out",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    if (bk.checked_out_at) {
      return failure(
        "Child is already checked out",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("session_bookings")
      .update({
        checked_out_at: new Date().toISOString(),
        checked_out_by: context.user.id,
      })
      .eq("id", bookingId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message = err instanceof Error ? err.message : "Failed to check out";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UNDO CHECK-IN (Kiosk mistake correction)
// ============================================================
// Permission: CHECKIN_CHECKOUT
// Clears the check-in timestamp. Only works if not yet
// checked out.
// ============================================================

export async function undoCheckIn(
  bookingId: string,
): Promise<ActionResponse<SessionBooking>> {
  try {
    await requirePermission(Permissions.CHECKIN_CHECKOUT);
    const supabase = await createSupabaseServerClient();

    const { data: existing } = await supabase
      .from("session_bookings")
      .select("id, checked_in_at, checked_out_at")
      .eq("id", bookingId)
      .is("deleted_at", null)
      .single();

    if (!existing) {
      return failure("Booking not found", ErrorCodes.NOT_FOUND);
    }

    const bk = existing as {
      id: string;
      checked_in_at: string | null;
      checked_out_at: string | null;
    };

    if (!bk.checked_in_at) {
      return failure("Child is not checked in", ErrorCodes.VALIDATION_ERROR);
    }

    if (bk.checked_out_at) {
      return failure(
        "Cannot undo check-in after check-out",
        ErrorCodes.VALIDATION_ERROR,
      );
    }

    const { data, error } = await supabase
      .from("session_bookings")
      .update({
        checked_in_at: null,
        checked_in_by: null,
      })
      .eq("id", bookingId)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to undo check-in";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// MARK NO-SHOW
// ============================================================
// Permission: MANAGE_BOOKINGS
// Marks a confirmed booking as no_show. Child didn't attend
// but the fee may still apply depending on school policy.
// ============================================================

export async function markNoShow(
  bookingId: string,
): Promise<ActionResponse<SessionBooking>> {
  try {
    await requirePermission(Permissions.MANAGE_BOOKINGS);
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("session_bookings")
      .update({ status: "no_show" as BookingStatus })
      .eq("id", bookingId)
      .eq("status", "confirmed")
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to mark no-show";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET SESSION BOOKINGS (Staff view — for session detail page)
// ============================================================
// Returns all bookings for a session with student details.
// Used on the session detail page and kiosk view.
// ============================================================

export async function getSessionBookings(
  sessionId: string,
): Promise<ActionResponse<SessionBookingWithDetails[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("session_bookings")
      .select(
        `
        *,
        student:students!session_bookings_student_id_fkey(id, first_name, last_name, date_of_birth, photo_url),
        booked_by_user:users!session_bookings_booked_by_fkey(id, first_name, last_name),
        session:program_sessions!session_bookings_session_id_fkey(
          id, date, start_time, end_time, status,
          program:programs!program_sessions_program_id_fkey(id, name, code, program_type)
        )
      `,
      )
      .eq("session_id", sessionId)
      .is("deleted_at", null)
      .order("status", { ascending: true })
      .order("created_at", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    return success((data ?? []) as SessionBookingWithDetails[]);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get bookings";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET KIOSK DATA (Today's sessions)
// ============================================================
// Permission: CHECKIN_CHECKOUT
// Returns today's sessions with booked children in a compact
// format optimised for the kiosk iPad view. Includes medical
// alert badges for safety.
// ============================================================

export interface KioskSessionData {
  session_id: string;
  program_name: string;
  program_code: string | null;
  start_time: string;
  end_time: string;
  location: string | null;
  bookings: KioskBookingRow[];
}

export async function getKioskData(): Promise<
  ActionResponse<KioskSessionData[]>
> {
  try {
    await requirePermission(Permissions.CHECKIN_CHECKOUT);
    const supabase = await createSupabaseServerClient();

    const today = new Date().toISOString().split("T")[0];

    // Get today's sessions
    const { data: sessions, error: sessError } = await supabase
      .from("program_sessions")
      .select(
        `
        id, start_time, end_time, location,
        program:programs!program_sessions_program_id_fkey(name, code)
      `,
      )
      .eq("date", today)
      .eq("status", "scheduled")
      .is("deleted_at", null)
      .order("start_time", { ascending: true });

    if (sessError) {
      return failure(sessError.message, ErrorCodes.DATABASE_ERROR);
    }

    if (!sessions || sessions.length === 0) {
      return success([]);
    }

    const kioskSessions: KioskSessionData[] = [];

    for (const sess of sessions as Array<Record<string, unknown>>) {
      const sessId = sess.id as string;
      const program = sess.program as { name: string; code: string | null };

      // Get confirmed bookings with student info
      const { data: bookings } = await supabase
        .from("session_bookings")
        .select(
          `
          id, checked_in_at, checked_out_at,
          student:students!session_bookings_student_id_fkey(
            id, first_name, last_name, photo_url
          )
        `,
        )
        .eq("session_id", sessId)
        .eq("status", "confirmed")
        .is("deleted_at", null)
        .order("created_at", { ascending: true });

      // Get medical conditions for these students
      const studentIds = (
        (bookings ?? []) as Array<Record<string, unknown>>
      ).map((b) => (b.student as { id: string }).id);

      let medicalMap = new Map<
        string,
        { has_conditions: boolean; summary: string | null }
      >();

      if (studentIds.length > 0) {
        const { data: conditions } = await supabase
          .from("medical_conditions")
          .select("student_id, condition_name, severity")
          .in("student_id", studentIds)
          .is("deleted_at", null);

        // Group by student
        const conditionsByStudent = new Map<
          string,
          Array<{ condition_name: string; severity: string }>
        >();
        for (const c of (conditions ?? []) as Array<{
          student_id: string;
          condition_name: string;
          severity: string;
        }>) {
          if (!conditionsByStudent.has(c.student_id)) {
            conditionsByStudent.set(c.student_id, []);
          }
          conditionsByStudent.get(c.student_id)!.push(c);
        }

        for (const sid of studentIds) {
          const studentConditions = conditionsByStudent.get(sid) ?? [];
          medicalMap.set(sid, {
            has_conditions: studentConditions.length > 0,
            summary:
              studentConditions.length > 0
                ? studentConditions
                    .map((c) => `${c.condition_name} (${c.severity})`)
                    .join(", ")
                : null,
          });
        }
      }

      const kioskBookings: KioskBookingRow[] = (
        (bookings ?? []) as Array<Record<string, unknown>>
      ).map((b) => {
        const student = b.student as {
          id: string;
          first_name: string;
          last_name: string;
          photo_url: string | null;
        };
        const medical = medicalMap.get(student.id);

        return {
          booking_id: b.id as string,
          student_id: student.id,
          student_first_name: student.first_name,
          student_last_name: student.last_name,
          student_photo_url: student.photo_url,
          checked_in_at: b.checked_in_at as string | null,
          checked_out_at: b.checked_out_at as string | null,
          has_medical_conditions: medical?.has_conditions ?? false,
          medical_summary: medical?.summary ?? null,
        };
      });

      kioskSessions.push({
        session_id: sessId,
        program_name: program.name,
        program_code: program.code,
        start_time: sess.start_time as string,
        end_time: sess.end_time as string,
        location: sess.location as string | null,
        bookings: kioskBookings,
      });
    }

    return success(kioskSessions);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get kiosk data";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET STUDENT BOOKINGS (Parent view)
// ============================================================
// Returns upcoming bookings for a specific student.
// No special permission — RLS is_guardian_of handles access.
// ============================================================

export async function getStudentBookings(
  studentId: string,
  params: { from_date?: string; include_past?: boolean } = {},
): Promise<ActionResponse<SessionBookingWithDetails[]>> {
  try {
    await getTenantContext();
    const supabase = await createSupabaseServerClient();

    const fromDate = params.from_date ?? new Date().toISOString().split("T")[0];

    let query = supabase
      .from("session_bookings")
      .select(
        `
        *,
        student:students!session_bookings_student_id_fkey(id, first_name, last_name, date_of_birth, photo_url),
        booked_by_user:users!session_bookings_booked_by_fkey(id, first_name, last_name),
        session:program_sessions!session_bookings_session_id_fkey(
          id, date, start_time, end_time, status,
          program:programs!program_sessions_program_id_fkey(id, name, code, program_type)
        )
      `,
      )
      .eq("student_id", studentId)
      .is("deleted_at", null)
      .neq("status", "cancelled")
      .order("created_at", { ascending: false });

    // Note: filtering by session date requires a join filter.
    // We'll filter client-side for simplicity since bookings
    // per student are typically <100.

    const { data, error } = await query;

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    let bookings = (data ?? []) as SessionBookingWithDetails[];

    // Filter by date if not including past
    if (!params.include_past) {
      bookings = bookings.filter((b) => b.session.date >= fromDate);
    }

    return success(bookings);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get student bookings";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// GET PARENT'S CHILDREN BOOKINGS (aggregated)
// ============================================================
// Returns upcoming bookings across all children for the
// current parent. Powers the "My Bookings" portal page.
// ============================================================

export async function getMyChildrenBookings(
  params: { from_date?: string } = {},
): Promise<ActionResponse<SessionBookingWithDetails[]>> {
  try {
    const context = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // Get parent's children
    const { data: guardianships } = await supabase
      .from("guardians")
      .select("student_id")
      .eq("user_id", context.user.id)
      .is("deleted_at", null);

    const studentIds = (guardianships ?? []).map(
      (g) => (g as { student_id: string }).student_id,
    );

    if (studentIds.length === 0) {
      return success([]);
    }

    const fromDate = params.from_date ?? new Date().toISOString().split("T")[0];

    const { data, error } = await supabase
      .from("session_bookings")
      .select(
        `
        *,
        student:students!session_bookings_student_id_fkey(id, first_name, last_name, date_of_birth, photo_url),
        booked_by_user:users!session_bookings_booked_by_fkey(id, first_name, last_name),
        session:program_sessions!session_bookings_session_id_fkey(
          id, date, start_time, end_time, status,
          program:programs!program_sessions_program_id_fkey(id, name, code, program_type)
        )
      `,
      )
      .in("student_id", studentIds)
      .is("deleted_at", null)
      .neq("status", "cancelled")
      .order("created_at", { ascending: true });

    if (error) {
      return failure(error.message, ErrorCodes.DATABASE_ERROR);
    }

    // Filter to upcoming sessions
    const bookings = ((data ?? []) as SessionBookingWithDetails[]).filter(
      (b) => b.session.date >= fromDate,
    );

    return success(bookings);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to get bookings";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}

// ============================================================
// UPDATE BILLING STATUS
// ============================================================
// Permission: MANAGE_BOOKINGS
// Called by billing integration to mark bookings as billed,
// waived, or refunded.
// ============================================================

export async function updateBillingStatus(
  bookingId: string,
  billingStatus: BillingStatus,
  invoiceLineId?: string | null,
): Promise<ActionResponse<SessionBooking>> {
  try {
    await requirePermission(Permissions.MANAGE_BOOKINGS);
    const supabase = await createSupabaseServerClient();

    const updateData: Record<string, unknown> = {
      billing_status: billingStatus,
    };

    if (invoiceLineId !== undefined) {
      updateData.invoice_line_id = invoiceLineId;
    }

    const { data, error } = await supabase
      .from("session_bookings")
      .update(updateData)
      .eq("id", bookingId)
      .is("deleted_at", null)
      .select()
      .single();

    if (error) {
      return failure(error.message, ErrorCodes.UPDATE_FAILED);
    }

    return success(data as SessionBooking);
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "Failed to update billing status";
    return failure(message, ErrorCodes.INTERNAL_ERROR);
  }
}
